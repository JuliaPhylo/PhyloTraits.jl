var documenterSearchIndex = {"docs":
[{"location":"man/simulate_discrete/#Discrete-trait-simulation","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"","category":"section"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"rand can simulate discrete traits along a known network.","category":"page"},{"location":"man/simulate_discrete/#binary-trait-example","page":"Discrete trait simulation","title":"binary trait example","text":"","category":"section"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"For example, we can define a binary trait model with states \"carnivory\" (state 1) and \"non-carnivory\" (state 2), then ask for a trait to be simulated along our network. We can ask for 3 independent simulations, giving us 3 traits then, arranged in 3 rows.","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"m1 = BinaryTraitSubstitutionModel(1.0,2.0, [\"carnivory\", \"non-carnivory\"])","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"We also need a phylogeny. We re-use the network from the section on Discrete trait evolution. We then simulate traits with a stable random number generator (RNG) for reproducibility, but recommend using the default RNG by simply removing the argument rng below.","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"net = readnewick(\"(O:4,(A:3,((B:0.4)#H1:1.6::0.92,((#H1:0::0.08,C:0.4):0.6,(D:.2,E:.2):0.8):1):1):1);\");\nusing StableRNGs; rng = StableRNG(123); # for reproducibility of this example\ntraitmatrix, nodecolumn = rand(rng, m1, net; ntraits=3);\ntraitmatrix","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"In this trait matrix, each column corresponds to a node, each row is a trait, and each entry gives the state of that trait for that node, as an index. To get the state labels:","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"labs = getlabels(m1)\nlabs[traitmatrix]","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"The nodecolumn vector says which node corresponds to which column in the trait matrix, and we can compare to the node numbers in the network. For example, the first column corresponds to node -2, which is the root. (The root is always in the first column: that's where the simulation starts.)","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"nodecolumn\ngetroot(net)","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"As another example, we can extract the data for species \"A\". We first get the column number for \"A\" (column 12), then get A's data in that column.","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"findfirst(isequal(\"A\"), nodecolumn) # 12\nnodecolumn[12]\ntraitmatrix[:,12] # data for species A, as category indices\nlabs[traitmatrix[:,12]] # same data, as category names","category":"page"},{"location":"man/simulate_discrete/#example-of-DNA-simulation","page":"Discrete trait simulation","title":"example of DNA simulation","text":"","category":"section"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"Below we simulate 4 sites of a DNA alignment, independent from an HKY model with transition/transversion ratio κ=0.5 and stationary base frequencies of 0.2 for A and T and 0.3 for C and G:","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"and ","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"m2 = HKY85([.5], [0.20, 0.30, 0.30, 0.20])\nrng = StableRNG(36154); # again, for reproducibility\ntraitmatrix, nodecolumn = rand(rng, m2, net; ntraits=4);\ntraitmatrix\nlabs = getlabels(m2)","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"To get the data at the tips only, and in a specific order, we can do this.","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"taxa = tiplabels(net)\ntaxoncol = indexin(taxa, nodecolumn) # column indices to get taxa in order\nlabs[traitmatrix[:,taxoncol]] # trait at the tips only, ordered as in 'taxa'","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"This type of DNA data is from the package BioSymbols, for interoperability with packages from BioJulia.","category":"page"},{"location":"man/simulate_discrete/","page":"Discrete trait simulation","title":"Discrete trait simulation","text":"using BioSequences\nd = Dict(taxa[i] => LongDNA{4}(labs[traitmatrix[:,taxoncol[i]]])\n         for i in eachindex(taxa)) ","category":"page"},{"location":"man/phyloregression/#Continuous-trait-analysis","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"After inferring a phylogeny, we can take these phylogenetic relationships into account when studying the distribution of quantitative traits measured for extant species. This is the goal of phylogenetic comparative methods (PCM). With PhyloTraits, we can do so for a phylogeny that is either a tree, or a network with reticulations. More details can be found on the developments below in Bastide et al. 2018 [B18]","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"We assume a fixed network (which may be a tree), correctly rooted, with branch lengths proportional to calendar time. Below, we use a network that is time-consistent (all paths from the root to any given node have the same length) and ultrametric (all the tips are contemporary).","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"truenet = readnewick(\"((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\");","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"We can plot the network thanks to package PhyloPlots, which uses RCall. The name function is only instrumental here, to ensure that the figure is saved in the correct directory when the documentation is built. We only show the commands to actually save the plot in this first example for the interested reader, but we will hide those in the rest of the chapter, for the sake of clarity.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"using PhyloPlots, RCall\nname(x) = joinpath(\"..\", \"assets\", \"figures\", x)\nR\"svg\"(name(\"truenet.svg\"), width=8, height=4)\nR\"par\"(mar=[0,0,0,0])\nplot(truenet, useedgelength=true, showgamma=true);\nR\"dev.off()\"\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"(Image: truenet)","category":"page"},{"location":"man/phyloregression/#Model-and-variance-matrix","page":"Continuous trait analysis","title":"Model and variance matrix","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"Assuming that the network is known and that the continuous traits evolve under a Brownian Motion (BM) over time, it is possible to compute the expected variance covariance matrix between tip measurements. This can be done using function PhyloNetworks.vcv, whose syntax is inspired from the well known corresponding ape function.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"C = vcv(truenet)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"The matrix is returned as a DataFrame, with columns named by the tips of the network to allow for easy identification. Each row also corresponds to a tip in the network, and rows are ordered in the same way as columns.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"The computation of this matrix is based on the more general function PhyloNetworks.sharedpathmatrix. It is at the core of all the Phylogenetic Comparative Methods described below.","category":"page"},{"location":"man/phyloregression/#Phylogenetic-regression","page":"Continuous trait analysis","title":"Phylogenetic regression","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"Assume that we measured three continuous traits in the data frame below. We want to study the impact of traits 1 and 2 on trait 3. To do that, we can perform a phylogenetic regression.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"To make sure that data are mapped to the correct tip in the phylogeny, even though the tips might be ordered differently in the data frame compared to the phylogeny, our data needs to have a column with the names of the tips in the network. If this column is labeled tipnames, fitting the data will not require an extra option.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"using DataFrames\ndat = DataFrame(\n  trait1 = [ 2.668,  3.696,  4.541, 4.846,  2.268, -0.331],\n  trait2 = [-3.008, -4.146, -2.338, 0.655, -3.339, -4.566],\n  trait3 = [15.424, 17.333, 18.115, 18.81, 13.337, 10.012],\n  tipnames = [\"D\", \"C\", \"A\", \"B\", \"E\", \"O\"]\n)\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"Phylogenetic regression / ANOVA is based on the GLM package, with the network as an extra argument, using function phylolm.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"using StatsModels # for statistical model formulas\nfitTrait3 = phylolm(@formula(trait3 ~ trait1 + trait2), dat, truenet)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"The REML criterion is used by default, for estimating the variance parameter(s). ML could be used instead with option reml=false.   From this, we can see that the intercept, the coefficient for trait 1 and the variance of the noise are correctly estimated (given that there are only 6 taxa). In addition, the Student T test for the coefficient associated with trait 2 has a high p-value, which means that this coefficient is not significantly different from 0. This is consistent with the way we simulated trait 3.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"The function returns an object of type PhyloNetworkLinearModel<:GLM.LinPredModel. It is a subtype of the GLM type LinPredModel, which means that all base functions from Julia StatsBase can be applied to it. See the documentation for this type for a list of all functions that can be used. Some functions allow the user to retrieve directly the estimated parameters of the BM, and are specific to this object.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"sigma2_phylo(fitTrait3) # estimated variance of the BM\nmu_phylo(fitTrait3) # estimated root value of the BM","category":"page"},{"location":"man/phyloregression/#Ancestral-state-reconstruction","page":"Continuous trait analysis","title":"Ancestral state reconstruction","text":"","category":"section"},{"location":"man/phyloregression/#From-known-parameters","page":"Continuous trait analysis","title":"From known parameters","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"If we assume that we know the exact model of evolution that generated the traits, we can do ancestral trait reconstruction. Here, we simulated trait 1 ourselves (see next section), so we can use the true process with the true parameters. In other words, we can reconstruct the state at the internal nodes, given the values at the tips, the known value at the root (2) and the known BM variance (0.5).","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"ancTrait1 = ancestralreconstruction(truenet, dat.trait1, ParamsBM(2, 0.5))\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"Function ancestralreconstruction creates an object with type ReconstructedStates. Several extractors can be applied to it:","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"using StatsAPI, StatsBase # for predict and stderror()\npredict(ancTrait1) # predictions\nstderror(ancTrait1) # associated standard errors\npredict(ancTrait1, interval=:prediction, level=0.90) # prediction interval (at level 90%)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"We can plot the ancestral states or prediction intervals on the tree, using the nodelabel argument of the PhyloPlots.plot function.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"R\"svg\"(name(\"ancestral_expe.svg\"), width=8, height=4) # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, nodelabel=predict(ancTrait1, text=true), nodelabeladj=[1,-0.1],\n     tipoffset=0.1);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"(Image: ancestral_expe)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"ancInt = predict(ancTrait1, interval=:prediction, text=true) # format the prediction intervals for the plot\nR\"svg\"(name(\"ancestral_predint.svg\"), width=8, height=4) # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, tipoffset=0.1,\n     nodelabel=ancInt[!,[:nodenumber,:interval]], nodelabeladj=[1,-.1]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"(Image: ancestral_predint)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"The PhyloTraits.predict function has an optional argument to state the level of the prediction interval. If not given, the default value is 0.95.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"It is also possible to plot both the reconstructed state and the predicted value on the same plot, using the optional keyword argument combine. As shown below, we could also use the RCall method from the PhyloPlots.plot function.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"ancInt = predict(ancTrait1, interval=:prediction, text=true, combine=true) \nplot(truenet, tipoffset=0.1, nodelabel = ancInt[!,[:nodenumber,:interval]],\n     nodelabeladj=[1,-0.1]);\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"These plots tend to be quite busy, even for small networks.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"As we know the true ancestral states here, we can compare them to our estimation. In this example, we see that the 95% prediction (ancestral state reconstruction) intervals contain the true simulated value, at all ancestral nodes.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"pred = predict(ancTrait1, interval=:prediction);\nDataFrame(\n  lower     = pred[1:7, :lower],                         # lower bound of 95% prediction interval\n  trueValue = [3.312,4.438,3.922,3.342,2.564,1.315,2.0], # from sim1[:internalnodes] in next section\n  upper     = pred[1:7, :upper]                          # upper bound\n )","category":"page"},{"location":"man/phyloregression/#From-estimated-parameters","page":"Continuous trait analysis","title":"From estimated parameters","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"In real applications though, we do not have access to the true parameters of the process that generated the data. We can estimate them using the previous function. To fit a regular BM, we just need to do a regression of trait 1 against a simple intercept:","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"fitTrait1 = phylolm(@formula(trait1 ~ 1), dat, truenet)\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"We can then apply the ancestralreconstruction function directly to the fitted object:","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"ancTrait1Approx = ancestralreconstruction(fitTrait1)\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"The prediction intervals ignore the fact that we estimated the process parameters, so they are less accurate and the function throws a warning. Note that this warning will only show once in a given julia session. The output is an object of the same ReconstructedStates type as earlier, and the same extractors can be applied to it:","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"R\"svg\"(name(\"ancestral1.svg\"), width=8, height=4) # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, nodelabel=predict(ancTrait1Approx, text=true), nodelabeladj=[1,-0.1]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"(Image: ancestral1)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"For convenience, the two steps described above (fitting against the intercept, and then do ancestral state reconstruction) can be done all at once with a single call of the function ancestralreconstruction on a DataFrame with the trait to reconstruct, and the tip labels:","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"datTrait1 = DataFrame(trait1 = dat[:,:trait1], tipnames = dat[:,:tipnames])\nwith_logger(nowarninglogger) do # hide\nancTrait1Approx = ancestralreconstruction(datTrait1, truenet)\nnothing # hide\nend # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"ancInt = predict(ancTrait1Approx, interval=:prediction, level=0.9, text=true, combine=true) \nR\"svg\"(name(\"ancestral2.svg\"), width=8, height=4) # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, nodelabel=ancInt[!,[:nodenumber,:interval]], nodelabeladj=[1,-0.1]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"(Image: ancestral2)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"This produces the exact same results. Here, we chose a level of 90% for the plotted prediction intervals.","category":"page"},{"location":"man/phyloregression/#Data-imputation","page":"Continuous trait analysis","title":"Data imputation","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"Note that there is no theoretical difference between an internal node, for which we could not measure the value of the trait, and a missing value at a tip of the network. Consequently, the previous ancestralreconstruction function can be used to do data imputation. To see this, let's add some missing values in trait 1.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"allowmissing!(datTrait1, :trait1)\ndatTrait1[2, :trait1] = missing; # second row: for taxon C\nwith_logger(nowarninglogger) do # hide\nancTrait1Approx = ancestralreconstruction(datTrait1, truenet)\nnothing # hide\nend # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"ancInt = predict(ancTrait1Approx, interval=:prediction, text=true, combine=true) \nR\"svg\"(name(\"ancestral3.svg\"), width=8, height=4) # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, nodelabel=ancInt[!,[:nodenumber,:interval]], nodelabeladj=[1,-0.1]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"(Image: ancestral3)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"A prediction interval is shown for the missing values.","category":"page"},{"location":"man/phyloregression/#With-known-predictors","page":"Continuous trait analysis","title":"With known predictors","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"At this point, it might be tempting to apply this function to trait 3 as a linear combination of trait 1 and a phylogenetic noise, to get a better ancestral state reconstruction via using its correlation with trait 1. However, this cannot be done directly:","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"ancTrait3 = ancestralreconstruction(fitTrait3) # throws an error","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"This is because the model to fit the trait (a regression with one predictor and an intercept) used a predictor for which we don't know the ancestral states. The regression model accounted for that.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"The only option we have is to provide the function with the predictor's ancestral states, if they are known. They are actually known in this toy example because we generated the data ourselves (see next section), so we can reconstruct our trait doing the following:","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"with_logger(nowarninglogger) do # hide\nglobal ancTrait3=1 # hide\nancTrait3 = ancestralreconstruction(fitTrait3, # model with estimated coefs etc.\n  hcat(ones(7,1),\n  [ 3.312, 4.438,  3.922,  3.342,  2.564,  1.315,  2.0], # from sim1[:internalnodes]\n  [-3.62, -0.746, -2.217, -3.612, -2.052, -2.871, -2.0]) # from sim2[:internalnodes]\n)\nnothing # hide\nend # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"ancInt = predict(ancTrait3, interval=:prediction, text=true, combine=true) \nR\"svg\"(name(\"ancestral4.svg\"), width=8, height=4) # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, nodelabel=ancInt[!,[:nodenumber,:interval]], nodelabeladj=[1,-0.1]);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"(Image: ancestral4)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"where we provided the ancestral predictors as a matrix, containing the intercept, and the known predictor at internal nodes. We must be very careful with this function, as no check is done for the order of the predictors, or the order of their values that must be the same as the internal nodes of the phylogeny. As ancestral predictors are often unknown, the use of this functionality is discouraged.","category":"page"},{"location":"man/phyloregression/#Phylogenetic-ANOVA","page":"Continuous trait analysis","title":"Phylogenetic ANOVA","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"The phylolm function is based on the lm function from GLM. This means that it inherits from most of its features, and in particular, it can handle formulas with factors (discrete predictors) and interactions. For example, in lizards, we might want to do a regression of toe length on body length and the region where each species is found, where this region is coded into 4 categories (say). We might also want to include an interaction effect between body length and region. (This model is just meant to show the possibilities of the function).","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"To illustrate the use of categorical predictors of particular interest in a network with reticulations, let's assume that some transgressive evolution took place after the hybridization event, so that species \"A\" and \"B\" have a larger mean compared to the others (see [B18] for transgressive evolution after a reticulation event).","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"δ = 5.0; # value of heterosis\nunderHyb = [n == \"A\" || n == \"B\" for n in dat[:,\"tipnames\"]] # tips under hybrid\nunderHyb\nfor i in 1:nrow(dat)\n    underHyb[i] && (dat[i,:trait3] += δ) # add delta to tips A and B\nend\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"select(dat, [:trait3, :tipnames]) # trait3 changed: +5 added to A and B by previous loop","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"The categorical variable underHyb separates tips \"A\" and \"B\" from the others. We need to consider it as a factor, not a numerical variable. One way is to make it a vector of strings, as done below. An alternative way would be to add and use the CategoricalArrays package, then transform the column underHyb to be categorical (shown in commments).","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"dat.underHyb = string.(underHyb); # adds a new column\n# using CategoricalArrays\n# transform!(dat, :underHyb => categorical, renamecols=false)\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"dat","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"Now we can include this reticulation variable in the regression.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"fitTrait = phylolm(@formula(trait3 ~ trait1 + underHyb), dat, truenet)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"In this case, the categorical variable indicating which tips are descendants of the reticulation event is indeed relevant, and the transgressive evolution effect is recovered.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"This is a very simple example of how to include transgressive evolution, but some general functions to test for it, on networks with more than one hybrid, are also available.","category":"page"},{"location":"man/phyloregression/#Pagel's-Lambda","page":"Continuous trait analysis","title":"Pagel's Lambda","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"One classical question about trait evolution is the amount of \"phylogenetic signal\" in a trait or in the residuals of a linear relationship, that is, the importance of the tree structure to explain variation in the observed traits (or in the residuals). One way of measuring that is to use Pagel's lambda transformation of the branch lengths [P99]. This model assumes a BM on a tree where the internal branches are multiplied by a factor λ, while the external branches are modified so that the total height of the tree is constant. Hence, λ varies between 0 (the tree has no influence on the data) and 1 (the tree is unchanged). Using the same branch length transformations, this model can be straightforwardly extended to phylogenetic networks.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"This transformation assumes a time-consistent and ultrametric phylogeny, in which all paths from the root to any tip has the same length: the \"height\" of the phylogeny referred to above.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"We can illustrate this with the predictor trait we used earlier. We use the same function as before, only indicating the model we want to use:","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"fitPagel = phylolm(@formula(trait1 ~ 1), dat, truenet, model=\"lambda\")","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"As this trait 1 was indeed generated according to a plain BM on the phylogeny (see next section), the estimated λ should be close to 1. It can be extracted with function lambda_estim:","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"lambda_estim(fitPagel)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"For models in which the covariance is estimated, like Pagel's lambda, model comparisons should use a likelihood ratio test with the function lrtest, because the f-test (see below) is not applicable.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"If the models being compared have different predictors, then models should be fit with maximum likelihood instead of the default REML criterion in order to do a likelihood ratio test: use option reml=false for this.","category":"page"},{"location":"man/phyloregression/#Test-of-transgressive-evolution","page":"Continuous trait analysis","title":"Test of transgressive evolution","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"In the ANOVA section above, we showed how to include transgressive evolution in a simple case, and we did so manually. In general, transgressive evolution can be seen as a particular example of a shifted BM on the phylogenetic network, in which the trait evolves as a BM on the network, but shifts at a reticulation. The value of the shift may be the same across all reticulations, or may differ between reticulations.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"For identifiability reasons, each transgressive shift is applied to the edge below a reticulation. In our network above, there is a single reticulation and the edge below it is edge 6:","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"R\"svg\"(name(\"truenet_with_numbers.svg\"), width=8, height=4) # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, useedgelength=true, showedgenumber=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"(Image: truenet_with_numbers)","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"Let's assume we measured a trait that we hypothesized underwent a shift at some or all ancestral reticulations. To test this hypothesis, we can use the  custom columns of the PhyloNetworks.descendencematrix, that can be directly defined thanks to function descendencedataframe.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"df_shift = descendencedataframe(truenet) # regressors matching Hybrid Shifts","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"This creates a dataframe, with one column for each hybrid node in the network, named according to the number of the edge after the hybrid. In column shift_6, a row has a 0 if the corresponding species is not a descendant of the reticulation, otherwise has the proportion of its genome that was inherited from this reticulation. Here, A and B's ancestry if fully inherited from edge 6, below the one reticulation in the network.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"We can use the columns in this dataframe as regressors (predictors) in the phylolm function. Their coefficients will measure the shift after each reticulation. In the example below, the species names are listed in a different order than in df_shift, and contained in a column called \"species\", to show how this is handled to merge and then fit the data.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"dat = DataFrame(  # trait data\n  trait = [3.510, 2.195, 1.869, 4.839, 5.027, -0.679],\n  species = [\"O\", \"D\", \"C\", \"A\", \"B\", \"E\"]);\ndat = innerjoin(dat, df_shift, on = [:species => :tipnames]) # trait + shift predictors\nfit_sh = phylolm(@formula(trait ~ shift_6), dat, truenet, tipnames=:species) # fit","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"Here, because there is only one hybrid in the network, we can directly see whether the ancestral transgressive evolution is significant or not thanks to the Student T-test on the coefficient associated with shift_6. In more complex cases, it is possible to do a Fisher F-test, thanks to the GLM function ftest.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"fit_null = phylolm(@formula(trait ~ 1), dat, truenet, tipnames=:species) # null (no shift)\nftest(fit_null, fit_sh)  # nested models","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"Here, this test is equivalent to the Fisher F test, and gives the same p-value.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"note: Warnings from GLM\nA warning may appear, saying \"Starting from GLM.jl 1.8, null model is defined as having no predictor at all when a model without an intercept is passed.\"Why? ftest is inherited from the GLM package, which does not know that the intercept term is not a column of ones after transformation to remove the phylogenetic correlation. This is why ftest sends a warning for each model, when multiple models are compared.\nThese specific warnings can be ignored:\nF values and p-values are correct\nR² values are also correct: they are obtained with the r2 function for phylogenetic linear models.A future version of the package will attempt to remove these warnings specifically.","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"Note that models need to be ordered by complexity, when given to ftest: either from most complex to most simple, or from most simple to most complex. In the output table, models are listed in the order in which they were given. If the most complex model is given first, as done above, the table lists the most complex H₁ (with shifts) first, and the null model H₀ is listed as the second model.","category":"page"},{"location":"man/phyloregression/#References","page":"Continuous trait analysis","title":"References","text":"","category":"section"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"[B18]: Bastide, Solís-Lemus, Kriebel, Sparks, Ané (2018): Phylogenetic Comparative Methods for Phylogenetic Networks with Reticulations. Systematic Biology 67(5):800–820. doi:10.1093/sysbio/syy033","category":"page"},{"location":"man/phyloregression/","page":"Continuous trait analysis","title":"Continuous trait analysis","text":"[P99]: Pagel M (1999). Inferring the historical patterns of biological evolution. Nature. 401: 877–884. doi:10.1038/44766","category":"page"},{"location":"man/fitDiscrete/#Discrete-trait-evolution","page":"Discrete trait analysis","title":"Discrete trait evolution","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"With a phylogenetic network structure inferred, we can now estimate how quickly traits have evolved over time using a likelihood model. These traits should be discrete characteristics of a species such as feather color, diet type, or DNA in aligned genetic sequences.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"As with continuous trait evolution, we assume a fixed network, correctly rooted, with branch lengths proportional to calendar time. We start with a network, then add data about the tips of this network.","category":"page"},{"location":"man/fitDiscrete/#Reading-trait-data","page":"Discrete trait analysis","title":"Reading trait data","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"The simplest way is to use a vector of species names with a data frame of traits:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"# read in network\nnet = readnewick(\"(O:4,(A:3,((B:0.4)#H1:1.6::0.92,((#H1:0::0.08,C:0.4):0.6,(D:.2,E:.2):0.8):1):1):1);\");\n# read in trait data\nspecies = [\"C\",\"A\",\"D\",\"B\",\"O\",\"E\"];\ndat = DataFrame(trait=[\"hi\",\"lo\",\"lo\",\"hi\",\"lo\",\"lo\"])\nnothing # hide","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"If the species names and trait data are in the same data frame, read in your data frame then subset the data like this:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"dat = DataFrame(\n  species=[\"C\",\"A\",\"D\",\"B\",\"O\",\"E\"],\n  trait=[\"hi\",\"lo\",\"lo\",\"hi\",\"lo\",\"lo\"]\n);\nspecies = dat.species # or: dat[!, :species]\nselect!(dat, Not(:species)) # select all columns except for :species; modifies dat in place\nnothing # hide","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"Let's plot the network and map the data onto it:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"using RCall, PhyloPlots\nR\"svg\"(figname(\"fitdiscrete_trait_net_1.svg\"), width=4, height=3); # hide\nR\"par\"(mar=[0,0,0,0]); # to reduce margins\nres = plot(net, tipoffset=0.3); # has point coordinates, for data annotation\no = indexin(tiplabels(net), species)\n# o = 5,2,4,1,3,6 here: order to match taxa from \"species\" to tip labels\nspecies[o] == tiplabels(net) # true :) sanity check\ntraitcolor = map(x -> (x==\"lo\" ? \"grey\" : \"red\"), dat.trait[o])\nndf = res[:node_data] # node data frame: info for plotting nodes\nleaves = ndf[!,:lea]\nR\"points\"(x=ndf[leaves,:x] .+0.1, y=ndf[leaves,:y],\n          pch=16, col=traitcolor, cex=1.5); # adds grey & red points at tips\nR\"legend\"(x=1, y=7, legend=[\"hi\",\"lo\"], pch=16, col=[\"red\",\"grey\"],\n          title=\"my trait\", bty=\"n\",var\"title.adj\"=0);\n# next: add to gene flow edge the proportion γ of genes affected\nhi = findfirst([!e.ismajor for e in net.edge]) # hi = 6 : \"h\"ybrid \"i\"ndex\n# hi = index of gene flow edge (minor hybrid) in net: horizontal segment\nedf = res[:edge_data]\nR\"text\"(edf[hi,:x]-0.3, edf[hi,:y]-0.1, edf[hi,:gam],\n        col=\"deepskyblue\", cex=0.75); # add the γ value\nR\"dev.off\"(); # hide\nnothing # hide","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"(Image: net_1)","category":"page"},{"location":"man/fitDiscrete/#Substitution-models","page":"Discrete trait analysis","title":"Substitution models","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"After reading in your data, we need to choose a model to describe how evolutionary changes (or substitutions, in the case of DNA) happened over time. Available Markov substitution models are described below.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"For general trait types, use one of these three models:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":":BTSM Binary Trait Substitution Model (2 states, rates unconstrained)\n:ERSM Equal Rates Substitution Model (k states, all transitions possible with equal rates)\n:TBTSM Two Binary Trait Substitution Model (though not fully implemented yet)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"To infer evolutionary rates, run fitdiscrete on the network and data. It will calculate the maximum likelihood score of one or more discrete trait characters at the tips on a fixed network.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"Along each edge, evolutionary changes are modeled with a continous time Markov model.\nAt a hybrid node, the trait is assumed to be inherited from one or the other of its parents (immediately before the reticulation event), with probabilities equal to the inheritance γ of each parent edge, which is given by the network.\nAt the root of the network, a uniform distribution among the possible states is assumed a priori.\nThe model ignores incomplete lineage sorting (e.g. hemiplasy).","category":"page"},{"location":"man/fitDiscrete/#parameter-estimation-and-model-fit","page":"Discrete trait analysis","title":"parameter estimation & model fit","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"The example below if for a binary trait, first using a model assuming equal rates (from lo to hi and from hi to lo); then using a model allowing for distinct rates. The option optimizeQ=false causes transition rates to stay at their starting values, without being optimized.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"s1 = fitdiscrete(net, :ERSM, species, dat; optimizeQ=false)\ns2 = fitdiscrete(net, :BTSM, species, dat; optimizeQ=false)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"The default rates, which act as starting value if rates were to be optimized, are chosen equal to the inverse of the total edge lengths in the network (or 1/numberoftaxa if all branch lengths are missing).","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"By default optimizeQ = true, such that fitdiscrete estimates the parameters of the rate matrix Q.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"s3 = fitdiscrete(net, :ERSM, species, dat)\ns4 = fitdiscrete(net, :BTSM, species, dat)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"To compare the two models, we can use the Akaike criterion.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"using StatsBase\naic(s3)\naic(s4)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"Here, the equal-rate model is slightly favored (lower AIC), so we will use s3 below.","category":"page"},{"location":"man/fitDiscrete/#ancestral-state-prediction","page":"Discrete trait analysis","title":"ancestral state prediction","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"This is traditionally called \"ancestral state reconstruction\", but we do not actually reconstruct anything. We make predictions for (past of present-day) values, hopefully with some measure to quantify our uncertainty.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"# show(ancestralreconstruction(s3), allrows=true)\nancestralreconstruction(s3)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"Rows 1-6 correspond to the tips, with known values. We see much prediction uncertainty at most of the internal nodes. To see where these internal nodes (7-13/H1) are, we need to look at the network stored within the fitted model. This network might differ somewhat from the input network in case taxa with missing data where pruned, and with edges possibly renumbered.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"R\"svg\"(figname(\"fitdiscrete_trait_net_2.svg\"), width=4, height=3); # hide\nR\"par\"(mar=[0,0,0,0]); # hide\nplot(s3.net, shownodenumber=true, shownodelabel=true, tipoffset=0.2);\nR\"dev.off\"(); # hide\nnothing # hide","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"(Image: net_2)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"Looking back at the posterior probabilities of states \"hi\" and \"lo\" at each node from the ancestral 'prediction' table above, we see that there is more uncertainty near the root, and less uncertainty near the tips. The most recent common ancestor of D and E (node 11), in particular, is predicted to be \"lo\" with fairly high certainty.","category":"page"},{"location":"man/fitDiscrete/#impact-of-gene-flow-on-the-trait","page":"Discrete trait analysis","title":"impact of gene flow on the trait","text":"","category":"section"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"An interesting question is whether there is evidence that B obtained it's \"hi\" state via gene flow. The prior probability for this is γ: the supposedly known proportion of genes inherited via gene flow, which is part of the network (along with branch lengths). Here, this prior probability of trait inheritance via gene flow is:","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"net.edge[6].gamma # the minor hybrid edge was edge 6, from above","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"We can compare this to the posterior probability, and get a Bayes factor to compare the two hypotheses: gene flow vs. vertical inheritance.","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"exp(s3.priorltw[1]) # prior: for vertical inheritance. \"ltw\" = log tree weight\nexp(s3.priorltw[2]) # prior: for gene flow inheritance, same as γ above\npostltw = PhyloTraits.posterior_logtreeweight(s3)\nexp(postltw[2])     # posterior: for gene flow inheritance\nfunction geneflowBF(fit)\n    postltw = PhyloTraits.posterior_logtreeweight(fit)\n    exp(postltw[2] - postltw[1] + fit.priorltw[1] - fit.priorltw[2])\nend\ngeneflowBF(s3)","category":"page"},{"location":"man/fitDiscrete/","page":"Discrete trait analysis","title":"Discrete trait analysis","text":"We get a Bayes factor greater than 1, so there is more evidence that the \"hi\" value of B was inherited via gene flow, than via vertical inheritance. But the Bayes factor is just barely above 1, so the evidence is very equivocal. This may not be surprising given that gene flow occurred between fairly closely related species, and that the data set is very small.","category":"page"},{"location":"man/example_fishes/#Empirical-example:-Xiphophorus-fishes","page":"Xiphophorus fishes","title":"Empirical example: Xiphophorus fishes","text":"","category":"section"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"We reproduce here the analyses on Xiphophorus fishes from Bastide et al. (2018), available on dryad.","category":"page"},{"location":"man/example_fishes/#Data-loading","page":"Xiphophorus fishes","title":"Data loading","text":"","category":"section"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"The data can be downloaded here:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"the time calibrated network;\nthe trait data on sword index and female preference for a sword, originally from Cui et al. (2013).","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"The files are also in the examples folder of the PhyloTraits package as  xiphophorus_networks_calibrated.tre and xiphophorus_morphology_Cui_etal_2013.csv.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"If not done already, load the packages needed for this analysis:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"using PhyloNetworks, PhyloTraits, PhyloPlots\nusing RCall, CSV, DataFrames\nusing StatsAPI, StatsBase, StatsModels\nname(x) = joinpath(\"..\", \"assets\", \"figures\", x); # hide\nnothing      # hide","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"then read in the networks data:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"examples_path = joinpath(dirname(pathof(PhyloTraits)), \"..\", \"examples\");\ntopologies = readmultinewick(joinpath(examples_path, \"xiphophorus_networks_calibrated.tre\"));\nnet3 = topologies[3]; # we will use the network with 3 reticulations\nR\"svg\"(name(\"net3.svg\"), width=8, height=4) # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net3; useedgelength=true); # topology + branch lengths\nR\"dev.off()\" # hide\nnothing      # hide","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"(Image: net3)","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"The file examples/xiphophorus_networks_calibrated.tre contains three calibrated networks, with 0, 1 or 3 reticulations (see Bastide et al. (2018) for details). In this tutorial, we use the network with 3 reticulations.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"We can rotate! some of the nodes to avoid crossing edges and produce a better figure:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"rotate!(net3, -4)\nrotate!(net3, -5)\nrotate!(net3, -6)\nrotate!(net3, -14)\nrotate!(net3, -16)\nrotate!(net3, -17)\nR\"svg\"(name(\"net3_rot.svg\"), width=8, height=4) # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net3; useedgelength=true); # topology + branch lengths\nR\"dev.off()\" # hide\nnothing      # hide","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"(Image: net3)","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"We can then read in the trait data:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"csvfile = joinpath(examples_path, \"xiphophorus_morphology_Cui_etal_2013.csv\")\ndat = CSV.read(csvfile, DataFrame);","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"Sometimes the trait data and phylogeny have non-overlapping taxa sets. PhyloTraits requires the data and phylogeny to have information on the same set of taxa. We will delete the rows in the trait data for the taxa that are missing in the network.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"taxa_net = tiplabels(net3); # extract list of taxa\nmissing_rows = Integer[];\nfor i in reverse(1:nrow(dat))\n    j = findfirst(isequal(dat.tipnames[i]), taxa_net)\n    if isnothing(j) # taxon not found in network\n        println(\"taxon \", dat.tipnames[i], \" (row $i) not found in network\")\n        push!(missing_rows,i)\n    end\nend\ndat = dat[setdiff(1:nrow(dat),missing_rows),:];","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"The snippet above should work fairly generically, assuming that the column with the taxa is labelled tipnames. Here, it tells us that taxon Xnezahualcoyotl (row 19) not found in network and thus our code (last line) removed it from our data frame dat.","category":"page"},{"location":"man/example_fishes/#Ancestral-state-prediction","page":"Xiphophorus fishes","title":"Ancestral state prediction","text":"","category":"section"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"As done in the manual, after fitting a model of trait evolution, we may wish to estimate the character at various internal nodes to gain insight on the ancestral states.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"For the ancestral states of the sword index:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"dat_si = dat[:, [:tipnames,:sword_index]];\nAS_si = ancestralreconstruction(dat_si, net3); # the ancestral state estimates\nR\"svg\"(name(\"anc_fish_si_est.svg\"), width=8, height=4) # hide\nR\"par(mar=c(.5,.5,.5,.5))\"; # hide\nplot(net3, nodelabel = predict(AS_si, text=true), xlim=[0,20]);\nR\"dev.off()\" # hide\nnothing      # hide","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"(Image: anc_fish_si_est)","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"The prediction intervals ignore the fact that we estimated the process parameters, so they are less accurate and the function throws a warning. This warning will only show once in a given julia session.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"To get the 90% credible interval in a text format to use as labels for plotting, we can use option text=true in the predict function.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"AS_si_int = predict(AS_si, interval=:prediction, level=0.90, text=true);\nR\"svg\"(name(\"anc_fish_si_ci.svg\"), width=8, height=4) # hide\nR\"par(mar=c(.5,.5,.5,.5))\"; # hide\nplot(net3, useedgelength=true, nodecex=0.7,\n     nodelabel=AS_si_int[!,[:nodenumber,:interval]]);\nR\"dev.off()\" # hide\nnothing      # hide","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"(Image: anc_fish_si_ci)","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"Note that here, the first plot ignores branch lengths, while the second one uses them (useedgelength=true).","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"As a consistency check, we can observe that the ancestral state prediction interval falls within the extrema of the trait itself:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"AS_si_int[findfirst(AS_si_int.nodenumber .== -2),:interval]\nextrema(dat[:,:sword_index])","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"We can do the same for the female preference for a sword:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"dat_fp = dat[:, [:preference, :tipnames]];\nwith_logger(nowarninglogger) do # hide\nglobal AS_fp=1 # hide\nAS_fp = ancestralreconstruction(dat_fp, net3);\nend # hide\nR\"svg\"(name(\"anc_fish_fp_est.svg\"), width=8, height=4) # hide\nR\"par(mar=c(.5,.5,.5,.5))\"; # hide\nplot(net3, xlim=[0,20], nodelabel=predict(AS_fp,text=true),\n     nodelabeladj=[1,-.05], nodecex=-.9);\nR\"dev.off()\" # hide\nnothing      # hide","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"(Image: anc_fish_fp_est)","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"AS_fp_int = predict(AS_fp, interval=:prediction, level=0.90, text=true);\nR\"svg\"(name(\"anc_fish_fp_ci.svg\"), width=8, height=4) # hide\nR\"par(mar=c(.5,.5,.5,.5))\"; # hide\nplot(net3, useedgelength=true, xlim=[-3,26], nodecex=-.9,\n     nodelabel=AS_fp_int[!,[:nodenumber,:interval]], nodelabeladj=[1,-.1]);\nR\"dev.off()\" # hide\nnothing      # hide","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"(Image: anc_fish_fp_ci)","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"AS_fp_int[findfirst(AS_fp_int.nodenumber .== -2),:interval]\nextrema(skipmissing(dat[:,:preference]))","category":"page"},{"location":"man/example_fishes/#Phylogenetic-signal:-Pagel's-lambda","page":"Xiphophorus fishes","title":"Phylogenetic signal: Pagel's lambda","text":"","category":"section"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"We can use Pagel's lambda transformation to asses the phylogenetic sigal.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"lambda_si = phylolm(@formula(sword_index ~ 1), dat, net3, model=\"lambda\")\nlambda_fp = phylolm(@formula(preference ~ 1),  dat, net3, model=\"lambda\";\n                    suppresswarnings=true)","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"On both traits we observe λ>1.0 when fitting the Pagel's lambda model; consequently, we would interpret the patterns in trait data to have high phylogenetic signal. Note that here, we observe λ values greater than 1.0: the observed value is the maximum value so that the transformation does not produce negative branch lengths.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"note: Warnings from PhyloTraits\nWhen fitting a Pagel's lambda model on a network that is not time consistent, a warning will appear and notify the user that the node heights from the major tree within the network will be used for analysis. Pagel's lambda models assume time consistency, making it important to calibrate a network prior to model fitting. In our case, if we run getnodeheights(net3) we will get an error showing that the different path lengths that lead to the time inconsistency is relatively small. The small difference between paths likely results in a minor difference when using the major tree node heights instead of well-calibrated heights.getnodeheights(net3)","category":"page"},{"location":"man/example_fishes/#Phylogenetic-regression-of-sword-index-versus-preference","page":"Xiphophorus fishes","title":"Phylogenetic regression of sword index versus preference","text":"","category":"section"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"Phylogenetic regression can help us anwser the question: does preference influence sword index?","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"R\"svg\"(name(\"sword_vs_preference.svg\"), width=5, height=5) # hide\nR\"par\"(mar=[3,3,.2,.2], las=1, mgp=[2,0.7,0]); # hide\nR\"plot\"(dat.preference, dat.sword_index,\n        xlab=\"female preference\", ylab=\"sword index\");\nR\"dev.off()\" # hide\nnothing      # hide","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"(Image: sword_vs_preference)","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"fit_BM = phylolm(@formula(sword_index ~ preference), dat, net3)\nfit_λ  = phylolm(@formula(sword_index ~ preference), dat, net3, model=\"lambda\"; suppresswarnings=true)\nlrtest(fit_BM,fit_λ)","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"On both Brownian motion and Pagel's lambda models, we find a positive –but statistically insignificant– relationship between mate preference and sword index.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"Further, when comparing AIC values between the models, we may conclude that including the extra λ parameter in the Pagel's lambda does not drastically improve the model's ability to explain the patterns in the data. Since the Brownian Motion model is nested within the Pagel's lambda model (BM assumes λ=1), we can use a likelihood ratio test to more formally conclude that the Pagel's lambda model does not significantly fit the data better than the Brownain Motion alone.","category":"page"},{"location":"man/example_fishes/#Transgressive-evolution","page":"Xiphophorus fishes","title":"Transgressive evolution","text":"","category":"section"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"To evaluate whether there was transgressive evolution that caused trait shifts at reticulation events, we can fit and compare different models of continuous trait evolution.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"Here we compare three different models:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"fit0: no effect of reticulation events on the trait expectation;\nfit1: all three reticulation events lead to the same shift value on the trait expectation;\nfit2: each reticulation events has its own shift value on the trait expectation.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"For the sword index, we get:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"df_shift = descendencedataframe(net3); # regressors matching Hybrid Shifts\ndat3 = leftjoin(dat, df_shift, on = :tipnames); # add regressors to data\nfit0 = phylolm(@formula(sword_index ~ 1),   dat3, net3) # no shift\nfit1 = phylolm(@formula(sword_index ~ sum), dat3, net3) # same shift at hybrids\nfit2 = phylolm(@formula(sword_index ~ shift_24 + shift_37 + shift_45),\n               dat3, net3) # different shifts at hybrid nodes\nwith_logger(nowarninglogger) do # hide\nftest(fit0, fit1, fit2)\nend # hide","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"From the p-values we might conclude that neither transgressive model can fit the data significantly better than the model without trait shifts.","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"For the female preference, we get:","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"fit0 = phylolm(@formula(preference ~ 1),   dat3, net3) # no shift\nfit1 = phylolm(@formula(preference ~ sum), dat3, net3) # same shift at hybrids\nfit2 = phylolm(@formula(preference ~ shift_24 + shift_37 + shift_45), dat3, net3) # different shifts at hybrid nodes\nwith_logger(nowarninglogger) do # hide\nftest(fit0, fit1, fit2)\nftest(fit0, fit2)\nend # hide","category":"page"},{"location":"man/example_fishes/","page":"Xiphophorus fishes","title":"Xiphophorus fishes","text":"The heterogeneous model gets some support, with effects in opposite directions (some positive, some negative).","category":"page"},{"location":"man/fitdiscreteDNA/#fitting-DNA-substitution-parameters-on-a-network","page":"DNA evolutionary models","title":"fitting DNA substitution parameters on a network","text":"","category":"section"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"The methods below model each DNA site as a trait, assuming that sites are unlinked, that is, they evolve independently of each other. In other words, this is a \"concatenation\" approach where sites from the same locus do not share information about their evolutionary path. This is appropriate if recombination is assumed to have occurred within genes.","category":"page"},{"location":"man/fitdiscreteDNA/#reading-in-an-alignment","page":"DNA evolutionary models","title":"reading in an alignment","text":"","category":"section"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"Like for trait evolution, fitdiscrete can be used. It can be given data in a variety of ways. For DNA, this is one way, using PhyloNetworks.readfastatodna:","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"# read in network\ndna_net = readnewick(\"((((((((((((((Ae_caudata_Tr275:1.0,Ae_caudata_Tr276:1.0):1.0,Ae_caudata_Tr139:1.0):1.0)#H1:1.0::0.6,((((((Ae_longissima_Tr241:1.0,Ae_longissima_Tr242:1.0):1.0,Ae_longissima_Tr355:1.0):1.0,(Ae_sharonensis_Tr265:1.0,Ae_sharonensis_Tr264:1.0):1.0):1.0,((Ae_bicornis_Tr408:1.0,Ae_bicornis_Tr407:1.0):1.0,Ae_bicornis_Tr406:1.0):1.0):1.0,((Ae_searsii_Tr164:1.0,Ae_searsii_Tr165:1.0):1.0,Ae_searsii_Tr161:1.0):1.0):1.0)#H2:1.0::0.6):1.0,(((Ae_umbellulata_Tr266:1.0,Ae_umbellulata_Tr257:1.0):1.0,Ae_umbellulata_Tr268:1.0):1.0,#H1:1.0::0.4):1.0):1.0,((Ae_comosa_Tr271:1.0,Ae_comosa_Tr272:1.0):1.0,(((Ae_uniaristata_Tr403:1.0,Ae_uniaristata_Tr357:1.0):1.0,Ae_uniaristata_Tr402:1.0):1.0,Ae_uniaristata_Tr404:1.0):1.0):1.0):1.0,(((Ae_tauschii_Tr352:1.0,Ae_tauschii_Tr351:1.0):1.0,(Ae_tauschii_Tr180:1.0,Ae_tauschii_Tr125:1.0):1.0):1.0,(#H2:1.0::0.4,((((Ae_mutica_Tr237:1.0,Ae_mutica_Tr329:1.0):1.0,Ae_mutica_Tr244:1.0):1.0,Ae_mutica_Tr332:1.0):1.0)#H4:1.0::0.6):1.0):1.0):1.0,(((T_boeoticum_TS8:1.0,(T_boeoticum_TS10:1.0,T_boeoticum_TS3:1.0):1.0):1.0,T_boeoticum_TS4:1.0):1.0,((T_urartu_Tr315:1.0,T_urartu_Tr232:1.0):1.0,(T_urartu_Tr317:1.0,T_urartu_Tr309:1.0):1.0):1.0):1.0):1.0,(((((Ae_speltoides_Tr320:1.0,Ae_speltoides_Tr323:1.0):1.0,Ae_speltoides_Tr223:1.0):1.0,Ae_speltoides_Tr251:1.0):1.0):1.0,#H4:1.0::0.4):1.0):1.0):1.0,Ta_caputMedusae_TB2:1.0):1.0,S_vavilovii_Tr279:1.0):1.0,Er_bonaepartis_TB1:1.0):1.0,H_vulgare_HVens23:1.0);\");\n# read in alignment in FASTA format\nfastafile = joinpath(dirname(pathof(PhyloTraits)), \"..\",\"examples\",\"Ae_bicornis_Tr406_Contig10132.aln\");\ndna_dat, dna_weights = readfastatodna(fastafile, true);\nnothing # hide","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"dna_dat\ndna_weights","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"Here, dna_dat is a single data frame containing both species names and trait data (site patterns). The alignment was summarized by listing each observed site pattern only once in dna_dat. dna_weights is a vector of weights, containing the number of times that each site pattern was observed.","category":"page"},{"location":"man/fitdiscreteDNA/#substitution-models-for-DNA","page":"DNA evolutionary models","title":"substitution models for DNA","text":"","category":"section"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"DNA-specific substitution models have 4 states: the 4 nucleotides from BioSymbols (listed here). Each model has a relative and an absolute version.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":":JC69 Jukes & Cantor 1969 model: one single rate for all transitions. The relative version has values -1 along the diagonal of the rate matrix (1 expected transition / unit of time). The absolute version has an extra parameter to scale the rate matrix.\n:HKY85 Hasegawa, Kishino & Yano 1985: treats transitions differently from transversions. The relative is scaled to predict an average of 1 transition / unit of time.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"We may allow for rate variation across sites using the :RV option.","category":"page"},{"location":"man/fitdiscreteDNA/#likelihood-of-a-fixed-network","page":"DNA evolutionary models","title":"likelihood of a fixed network","text":"","category":"section"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"In the examples below, none of the rate parameters are optimized, so we get to see the default starting values.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"d1 = fitdiscrete(dna_net, :JC69, dna_dat, dna_weights, :Gamma; optimizeQ=false, optimizeRVAS=false)\nd2 = fitdiscrete(dna_net, :HKY85, dna_dat, dna_weights, :Gamma; optimizeQ=false, optimizeRVAS=false, suppresswarnings=true)","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"When allowing for rate variation across sites with gamma-distributed rates, the default shape parameter α is 1.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"In the more interesting examples below, we optimize the evolutionary rates and the way rates vary across sites (which is the default).","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"d3 = fitdiscrete(dna_net, :JC69, dna_dat, dna_weights, :Gamma; ftolAbs=0.1, xtolAbs=0.01, suppresswarnings=true)","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"Lenient tolerance parameters ftolAbs etc. have been chosen here to make this example faster. Note that the fitted object contains a separate version of the input network, where any taxon without data has been pruned, and where branch numbers may have been modified.","category":"page"},{"location":"man/fitdiscreteDNA/","page":"DNA evolutionary models","title":"DNA evolutionary models","text":"d3.net","category":"page"},{"location":"lib/public/#public-documentation","page":"public","title":"public documentation","text":"","category":"section"},{"location":"lib/public/","page":"public","title":"public","text":"Documentation for PhyloTraits's public (exported) functions. Most functions are internal (not exported).","category":"page"},{"location":"lib/public/#functions-and-types","page":"public","title":"functions & types","text":"","category":"section"},{"location":"lib/public/#Base.rand","page":"public","title":"Base.rand","text":"rand([rng::AbstractRNG,]\n      net::HybridNetwork,\n      params::ParamsProcess,\n      checkpreorder::Bool=true)\n\nSimulate traits on net using the parameters params. For now, only parameters of type ParamsBM (univariate Brownian Motion) and ParamsMultiBM (multivariate Brownian motion) are accepted.\n\nThe simulation using a recursion from the root to the tips of the network, therefore, a pre-ordering of nodes is needed. If checkpreorder=true (default), PhyloNetworks.preorder! is called on the network beforehand. Otherwise, it is assumed that the preordering has already been calculated.\n\nReturns an object of type TraitSimulation, which has a matrix with the trait expectations and simulated trait values at all the nodes.\n\nSee examples below for accessing expectations and simulated trait values.\n\nExamples\n\nUnivariate\n\njulia> phy = readnewick(\"(A:2.5,((U:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5);\");\n\njulia> par = ParamsBM(1, 0.1) # BM with expectation 1 and variance 0.1.\nParamsBM:\nParameters of a BM with fixed root:\nmu: 1.0\nSigma2: 0.1\n\n\njulia> sim = rand(phy, par) # simulate along the network\nTraitSimulation:\nTrait simulation results on a network with 4 tips, using a BM model, with parameters:\nmu: 1.0\nSigma2: 0.1\n\nBelow, we re-run the same simulation but with our own fixed random number generator for reproducibility.\n\njulia> # using Pkg; Pkg.add(\"StableRNGs\") # to install StableRNGs if not done earlier\n\njulia> using StableRNGs; rng = StableRNG(791); # for reproducibility\n\njulia> sim = rand(rng, phy, par); # re-simulate\n\njulia> traits = sim[:tips] # extract simulated values at the tips.\n4-element Vector{Float64}:\n 0.5991561486238962\n 0.861066346792992\n 1.367634062992289\n 1.6439310845929571\n\njulia> tiplabels(sim) # name of tips, in the same order as values above\n4-element Vector{String}:\n \"A\"\n \"U\"\n \"C\"\n \"D\"\n\nSo, for example, the simulated trait value for taxon U (listed second) is ~0.86. For some purposes, we might want to access the values simulated at internal nodes, or at all nodes at once:\n\njulia> traits = sim[:internalnodes] # extract simulated values at internal nodes. Order: as in sim.M.internalnodenumbers\n5-element Vector{Float64}:\n 1.0716684901027937\n 1.6007823049044083\n 1.6756374575490327\n 1.2194286026283034\n 1.0\n\njulia> traits = sim[:all] # simulated values at all nodes, ordered as in sim.M.nodenumbers_toporder\n9-element Vector{Float64}:\n 1.0\n 1.2194286026283034\n 1.6756374575490327\n 1.367634062992289\n 1.0716684901027937\n 1.6007823049044083\n 1.6439310845929571\n 0.861066346792992\n 0.5991561486238962\n\nWe might also want to extract the expected mean values (without noise). This is not very interesting under a standard BM model, but may become interesting under more complex models (e.g. with shifts). We can do so with an extra :exp index:\n\njulia> traits = sim[:tips, :exp] # expected values at the tips (also works for sim[:all, :exp] and sim[:internalnodes, :exp]).\n4-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n\nMultivariate\n\njulia> phy = readnewick(\"(A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(V:0.5)#H1:0.5::0.6):1):0.5);\");\n\njulia> par = ParamsMultiBM([1.0, 2.0], [1.0 0.5; 0.5 1.0]) # BM with expectation [1.0, 2.0] and variance [1.0 0.5; 0.5 1.0].\nParamsMultiBM:\nParameters of a MBD with fixed root:\nmu: [1.0, 2.0]\nSigma: [1.0 0.5; 0.5 1.0]\n\njulia> using StableRNGs; rng = StableRNG(9851); # for reproducibility\n\njulia> sim = rand(rng, phy, par) # simulate on the phylogeny\nTraitSimulation:\nTrait simulation results on a network with 4 tips, using a MBD model, with parameters:\nmu: [1.0, 2.0]\nSigma: [1.0 0.5; 0.5 1.0]\n\n\njulia> traits = sim[:tips] # extract simulated values at the tips (each column contains the simulated traits for one node).\n2×4 Matrix{Float64}:\n 3.8013    0.839485  0.346092  1.91131\n 5.91725  -0.59143   0.458569  0.629048\n\nThe 2 rows to the 2 correlated traits and the columns correspond to the 4 taxa (tips). The order in which taxa are listed is obtained with tiplabels:\n\njulia> tiplabels(sim)\n4-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n \"V\"\n\nAs in the univariate case, we can also extract the values simulated at internal nodes, or all nodes (but listed in preorder), or expected mean values.\n\njulia> sim[:internalnodes] # simulated values at internal nodes. order: same as in sim.M.internalnodenumbers\n2×5 Matrix{Float64}:\n -0.604224  0.755722  2.14755  0.484292  1.0\n -0.338922  0.373921  1.15174  0.695561  2.0\n\njulia> traits = sim[:all]; # 2×9 Matrix: values at all nodes, ordered as in sim.M.nodenumbers_toporder\n\njulia> sim[:tips, :exp] # expected values (also works for sim[:all, :exp] and sim[:internalnodes, :exp])\n2×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 2.0  2.0  2.0  2.0\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.rand-Tuple{PhyloTraits.SubstitutionModel, Float64, AbstractVector{Int64}}","page":"public","title":"Base.rand","text":"rand([rng::AbstractRNG,]\n      model::TraitSubstitutionModel,\n      t::Float64,\n      start::AbstractVector{Int})\n\nSimulate discrete traits along one edge of length t. A random number generator rng is optional. start must be a vector of integers, each representing the starting value of one trait.\n\nexamples\n\njulia> m1 = BinaryTraitSubstitutionModel(1.0, 2.0)\nBinary Trait Substitution Model:\nrate 0→1 α=1.0\nrate 1→0 β=2.0\n\njulia> using StableRNGs; rng = StableRNG(135);\n\njulia> rand(rng, m1, 0.2, [1,2,1,2,1])\n5-element Vector{Int64}:\n 2\n 2\n 1\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Base.rand-Tuple{PhyloTraits.SubstitutionModel, PhyloNetworks.HybridNetwork}","page":"public","title":"Base.rand","text":"rand([rng::AbstractRNG,]\n      model::TraitSubstitutionModel,\n      net::HybridNetwork;\n      ntraits=1,\n      keepinternal=true,\n      checkpreorder=true)\n\nSimulate evolution of discrete traits on a rooted evolutionary network based on the supplied evolutionary model. Trait sampling is uniform at the root.\n\noptional arguments:\n\nntraits: number of traits to be simulated (default: 1 trait).\nkeepinternal: if true, export character states at all nodes, including internal nodes. if false, export character states at tips only.\n\noutput:\n\nmatrix of character states with one row per trait, one column per node; these states are indices in model.label, not the trait labels themselves.\nvector of node labels (for tips) or node numbers (for internal nodes) in the same order as columns in the character state matrix\n\nexamples\n\njulia> m1 = BinaryTraitSubstitutionModel(1.0, 2.0, [\"low\",\"high\"]);\n\njulia> net = readnewick(\"(((A:4.0,(B:1.0)#H1:1.1::0.9):0.5,(C:0.6,#H1:1.0::0.1):1.0):3.0,D:5.0);\");\n\njulia> using Random; Random.seed!(95);\n\njulia> trait, lab = rand(m1, net)\n([1 2 … 1 1], [\"-2\", \"D\", \"-3\", \"-6\", \"C\", \"-4\", \"H1\", \"B\", \"A\"])\n\njulia> trait\n1×9 Matrix{Int64}:\n 1  2  1  1  2  2  1  1  1\n\njulia> lab\n9-element Vector{String}:\n \"-2\" \n \"D\"  \n \"-3\" \n \"-6\" \n \"C\"  \n \"-4\" \n \"H1\"\n \"B\"  \n \"A\"  \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.Q-Tuple{BinaryTraitSubstitutionModel}","page":"public","title":"PhyloTraits.Q","text":"For a BinaryTraitSubstitutionModel, the rate matrix Q is of the form:\n\n-α  α\n β -β\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.Q-Tuple{PhyloTraits.SubstitutionModel}","page":"public","title":"PhyloTraits.Q","text":"Q(model)\n\nSubstitution rate matrix for a given substitution model: Q[i,j] is the rate of transitioning from state i to state j.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.ancestralreconstruction","page":"public","title":"PhyloTraits.ancestralreconstruction","text":"ancestralreconstruction(obj::SSM, trait::Integer = 1)\n\nEstimate the marginal probability of ancestral states for discrete character number trait (first trait by default). The parameters of the StatisticalSubstitutionModel object obj must first be fitted using fitdiscrete, and ancestral state reconstruction is conditional on the estimated parameters. If these parameters were estimated using all traits, they are used as is, to do ancestral state reconstruction of the particular trait of interest.\n\noutput: data frame with a first column for the node numbers, a second column for the node labels, and a column for each possible state: the entries in these columns give the marginal probability that a given node has a given state.\n\nwarnings:\n\nnode numbers and node labels refer to those in obj.net, which might have a different internal representation of nodes than the original network used to build obj.\nobj is modified: its likelihood fields (forward, directional & backward) are updated to make sure that they correspond to the current parameter values in obj.model, and to the trait of interest.\n\nlimitations: the following are not checked.\n\nAssumes that every node in the large network is also present (with descendant leaves) in each displayed tree. This is not true if the network is not tree-child...\nAssumes that the root is also in each displayed tree, which may not be the case if the root had a hybrid child edge.\n\nSee also posterior_logtreeweight and discrete_backwardlikelihood_trait! to update obj.backwardlik.\n\nexamples\n\njulia> net = readnewick(\"(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [\"lo\", \"hi\"]);\n\njulia> using DataFrames\n\njulia> dat = DataFrame(species=[\"C\",\"A\",\"B\",\"D\"], trait=[\"hi\",\"lo\",\"lo\",\"hi\"]);\n\njulia> fit1 = fitdiscrete(net, m1, dat);\n\njulia> asr = ancestralreconstruction(fit1)\n9×4 DataFrame\n Row │ nodenumber  nodelabel  lo        hi\n     │ Int64       String     Float64   Float64\n─────┼───────────────────────────────────────────\n   1 │          1  A          1.0       0.0\n   2 │          2  B          1.0       0.0\n   3 │          3  C          0.0       1.0\n   4 │          4  D          0.0       1.0\n   5 │          5  5          0.286021  0.713979\n   6 │          6  6          0.319456  0.680544\n   7 │          7  7          0.16855   0.83145\n   8 │          8  8          0.767359  0.232641\n   9 │          9  H1         0.782776  0.217224\n\njulia> using PhyloPlots\n\njulia> plot(fit1.net, nodelabel = asr[!,[:nodenumber, :lo]], tipoffset=0.2); # pp for \"lo\" state\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloTraits.ancestralreconstruction-Tuple{DataFrames.AbstractDataFrame, PhyloNetworks.HybridNetwork}","page":"public","title":"PhyloTraits.ancestralreconstruction","text":"ancestralreconstruction(fr::AbstractDataFrame, net::HybridNetwork; kwargs...)\n\nEstimate the ancestral traits on a network, given some data at the tips. Uses function phylolm to perform a phylogenetic regression of the data against an intercept (amounts to fitting an evolutionary model on the network).\n\nSee documentation on phylolm and ancestralreconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix]) for further details.\n\nReturns an object of type ReconstructedStates.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.ancestralreconstruction-Tuple{PhyloNetworkLinearModel}","page":"public","title":"PhyloTraits.ancestralreconstruction","text":"ancestralreconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix])\n\nFunction to find the ancestral traits reconstruction on a network, given an object fitted by function phylolm. By default, the function assumes that the regressor is just an intercept. If the value of the regressor for all the ancestral states is known, it can be entered in X_n, a matrix with as many columns as the number of predictors used, and as many lines as the number of unknown nodes or tips.\n\nReturns an object of type ReconstructedStates.\n\nExamples\n\njulia> using DataFrames, CSV # to read data file\n\njulia> phy = readnewick(joinpath(dirname(pathof(PhyloTraits)), \"..\", \"examples\", \"carnivores_tree.txt\"));\n\njulia> dat = CSV.read(joinpath(dirname(pathof(PhyloTraits)), \"..\", \"examples\", \"carnivores_trait.txt\"), DataFrame);\n\njulia> using StatsModels # for statistical model formulas\n\njulia> fitBM = phylolm(@formula(trait ~ 1), dat, phy);\n\njulia> ancStates = ancestralreconstruction(fitBM) # Should produce a warning, as variance is unknown.\n┌ Warning: These prediction intervals show uncertainty in ancestral values,\n│ assuming that the estimated variance rate of evolution is correct.\n│ Additional uncertainty in the estimation of this variance rate is\n│ ignored, so prediction intervals should be larger.\n└ @ PhyloTraits ~/build/JuliaPhylo/PhyloTraits.jl/src/traits_continuous.jl:2601\nReconstructedStates:\n───────────────────────────────────────────────\n  Node index      Pred.        Min.  Max. (95%)\n───────────────────────────────────────────────\n        -5.0   1.32139   -0.33824      2.98102\n        -8.0   1.03258   -0.589695     2.65485\n        -7.0   1.41575   -0.140705     2.97221\n        -6.0   1.39417   -0.107433     2.89577\n        -4.0   1.39961   -0.102501     2.90171\n        -3.0   1.51341   -0.220523     3.24733\n       -13.0   5.3192     3.92279      6.71561\n       -12.0   4.51176    2.89222      6.13131\n       -16.0   1.50947   -0.0186118    3.03755\n       -15.0   1.67425    0.196069     3.15242\n       -14.0   1.80309    0.309992     3.29618\n       -11.0   2.7351     1.17608      4.29412\n       -10.0   2.73217    1.12361      4.34073\n        -9.0   2.41132    0.603932     4.21871\n        -2.0   2.04138   -0.0340955    4.11686\n        14.0   1.64289    1.64289      1.64289\n         8.0   1.67724    1.67724      1.67724\n         5.0   0.331568   0.331568     0.331568\n         2.0   2.27395    2.27395      2.27395\n         4.0   0.275237   0.275237     0.275237\n         6.0   3.39094    3.39094      3.39094\n        13.0   0.355799   0.355799     0.355799\n        15.0   0.542565   0.542565     0.542565\n         7.0   0.773436   0.773436     0.773436\n        10.0   6.94985    6.94985      6.94985\n        11.0   4.78323    4.78323      4.78323\n        12.0   5.33016    5.33016      5.33016\n         1.0  -0.122604  -0.122604    -0.122604\n        16.0   0.73989    0.73989      0.73989\n         9.0   4.84236    4.84236      4.84236\n         3.0   1.0695     1.0695       1.0695\n───────────────────────────────────────────────\n\njulia> using StatsBase # for predict function\n\njulia> predict(ancStates)\n31×2 DataFrame\n Row │ nodenumber  prediction \n     │ Int64       Float64    \n─────┼────────────────────────\n   1 │         -5    1.32139\n   2 │         -8    1.03258\n   3 │         -7    1.41575\n   4 │         -6    1.39417\n   5 │         -4    1.39961\n   6 │         -3    1.51341\n   7 │        -13    5.3192\n   8 │        -12    4.51176\n  ⋮  │     ⋮           ⋮\n  25 │         10    6.94985\n  26 │         11    4.78323\n  27 │         12    5.33016\n  28 │          1   -0.122604\n  29 │         16    0.73989\n  30 │          9    4.84236\n  31 │          3    1.0695\n               16 rows omitted\n\njulia> predict(ancStates, interval = :prediction)\n31×4 DataFrame\n Row │ nodenumber  prediction  lower       upper     \n     │ Int64       Float64     Float64     Float64   \n─────┼───────────────────────────────────────────────\n   1 │         -5    1.32139   -0.33824     2.98102\n   2 │         -8    1.03258   -0.589695    2.65485\n   3 │         -7    1.41575   -0.140705    2.97221\n   4 │         -6    1.39417   -0.107433    2.89577\n   5 │         -4    1.39961   -0.102501    2.90171\n   6 │         -3    1.51341   -0.220523    3.24733\n   7 │        -13    5.3192     3.92279     6.71561\n   8 │        -12    4.51176    2.89222     6.13131\n  ⋮  │     ⋮           ⋮           ⋮           ⋮\n  25 │         10    6.94985    6.94985     6.94985\n  26 │         11    4.78323    4.78323     4.78323\n  27 │         12    5.33016    5.33016     5.33016\n  28 │          1   -0.122604  -0.122604   -0.122604\n  29 │         16    0.73989    0.73989     0.73989\n  30 │          9    4.84236    4.84236     4.84236\n  31 │          3    1.0695     1.0695      1.0695\n                                      16 rows omitted\n\njulia> using PhyloPlots # next: plot ancestral states on the tree\n\njulia> plot(phy, nodelabel = predict(ancStates), nodelabeladj=[1,-0.1]);\n\njulia> pred = predict(ancStates, interval = :prediction, text = true);\n\njulia> plot(phy, nodelabel = pred[!,[:nodenumber,:interval]]);\n\njulia> allowmissing!(dat, :trait);\n\njulia> dat[[2, 5], :trait] .= missing; # missing values allowed to fit model\n\njulia> fitBM = phylolm(@formula(trait ~ 1), dat, phy);\n\njulia> ancStates = ancestralreconstruction(fitBM);\n┌ Warning: These prediction intervals show uncertainty in ancestral values,\n│ assuming that the estimated variance rate of evolution is correct.\n│ Additional uncertainty in the estimation of this variance rate is\n│ ignored, so prediction intervals should be larger.\n└ @ PhyloTraits ~/build/JuliaPhylo/PhyloTraits.jl/src/traits_continuous.jl:2601\n\njulia> first(predict(ancStates), 3) # looking at first 3 nodes only\n3×2 DataFrame\n Row │ nodenumber  prediction \n     │ Int64       Float64    \n─────┼────────────────────────\n   1 │         -5     1.42724\n   2 │         -8     1.35185\n   3 │         -7     1.61993\n\njulia> first(predict(ancStates, interval=:prediction), 3)\n3×4 DataFrame\n Row │ nodenumber  prediction  lower      upper   \n     │ Int64       Float64     Float64    Float64 \n─────┼────────────────────────────────────────────\n   1 │         -5     1.42724  -0.373749  3.22824\n   2 │         -8     1.35185  -0.698432  3.40214\n   3 │         -7     1.61993  -0.17179   3.41165\n\njulia> plot(phy, nodelabel = predict(ancStates, text=true),\n            nodelabeladj=[1,-0.1]);\n\njulia> pred = predict(ancStates, interval = :prediction, text = true);\n\njulia> plot(phy, nodelabel = pred[!,[:nodenumber,:interval]]);\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.ancestralreconstruction-Tuple{PhyloNetworks.HybridNetwork, Vector, ParamsBM}","page":"public","title":"PhyloTraits.ancestralreconstruction","text":"ancestralreconstruction(net::HybridNetwork, Y::Vector, params::ParamsBM)\n\nCompute the conditional expectations and variances of the ancestral (un-observed) traits values at the internal nodes of the phylogenetic network (net), given the values of the traits at the tips of the network (Y) and some known parameters of the process used for trait evolution (params, only BM with fixed root works for now).\n\nThis function assumes that the parameters of the process are known. For a more general function, see ancestralreconstruction(obj::PhyloNetworkLinearModel[, X_n::Matrix]).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.descendencedataframe-Tuple{PhyloNetworks.HybridNetwork, Vector{PhyloNetworks.Node}}","page":"public","title":"PhyloTraits.descendencedataframe","text":"descendencedataframe(net::HybridNetwork, which=:allhybrids; checkpreorder=true)\ndescendencedataframe(net::HybridNetwork, node::Vector{Node}; checkpreorder=true)\ndescendencedataframe(net::HybridNetwork, edge::Vector{Edge}; checkpreorder=true)\n\nData frame containing the genomic proportion inherited by each taxon in net, from each hybrid node by default in the first method, or from each node or edge in the input vector in the second and third methods. The data frame has 1 row per tip (taxon) in the network and the following columns:\n\n1 column per edge or node, with columns named according to the pattern shift{edgenumber}\" where edge_number is the number of the edge associated with an input edge or node (in which case the parent edge is used)\n1 additional column labeled tipnames, containing the tip labels.\n\nThe shift_* columns in this data frame can be used as regressor vectors associated with shifts on input edges or on edges that are above input nodes. With option which=:allhybrids in last method, each shift column is associated with a hybrid node in net, to model a shift on the edge that is immediately below the hybrid node. This can be used to test for transgressive evolution: see examples below.\n\nThese methods use PhyloNetworks.descendencematrix, so net might be modified to store a vector of its nodes sorted in a pre-order.\n\nExamples\n\njulia> net = readnewick(\"(A:2.5,((B:1,#H1:0.5::0.4):1,(C:1,(D:0.5)#H1:0.5::0.6):1):0.5);\");\n\njulia> preorder!(net)\n\njulia> using PhyloPlots\n\njulia> plot(net, shownodenumber=true); # to locate nodes\n\njulia> nodes_shifts = indexin([1,-5], [n.number for n in net.node]) # Put a shift on edges ending at nodes 1 and -5\n2-element Vector{Union{Nothing, Int64}}:\n 1\n 7\n\njulia> params = ParamsBM(10, 0.1, ShiftNet(net.node[nodes_shifts], [3.0, -3.0],  net))\nParamsBM:\nParameters of a BM with fixed root:\nmu: 10.0\nSigma2: 0.1\n\nThere are 2 shifts on the network:\n──────────────────────────\n  Edge Number  Shift Value\n──────────────────────────\n          8.0         -3.0\n          1.0          3.0\n──────────────────────────\n\njulia> using Random; Random.seed!(2468); # sets the seed for reproducibility\n\njulia> sim = rand(net, params); # simulate a dataset with shifts\n\njulia> using DataFrames # to handle data frames\n\njulia> dat = DataFrame(trait = sim[:tips], tipnames = sim.M.tipnames);\n\njulia> dat = DataFrame(trait = [13.391976856737717, 9.55741491696386, 7.17703734817448, 7.889062527849697],\n        tipnames = [\"A\",\"B\",\"C\",\"D\"]) # hard-coded, to be independent of random number generator\n4×2 DataFrame\n Row │ trait     tipnames \n     │ Float64   String   \n─────┼────────────────────\n   1 │ 13.392    A\n   2 │  9.55741  B\n   3 │  7.17704  C\n   4 │  7.88906  D\n\njulia> dfr_shift = descendencedataframe(net, net.node[nodes_shifts]) # the regressors matching the shifts.\n4×3 DataFrame\n Row │ shift_1  shift_8  tipnames \n     │ Float64  Float64  String   \n─────┼────────────────────────────\n   1 │     1.0      0.0  A\n   2 │     0.0      0.0  B\n   3 │     0.0      1.0  C\n   4 │     0.0      0.6  D\n\njulia> dfr = innerjoin(dat, dfr_shift, on=:tipnames); # join data and regressors in a single dataframe\n\njulia> using StatsModels # for statistical model formulas\n\njulia> fitBM = phylolm(@formula(trait ~ shift_1 + shift_8), dfr, net; reml=false) # actual fit\nPhyloNetworkLinearModel\n\nFormula: trait ~ 1 + shift_1 + shift_8\n\nModel: Brownian motion\n\nParameter Estimates, using ML:\nphylogenetic variance rate: 0.0112618\n\nCoefficients:\n────────────────────────────────────────────────────────────────────────\n                Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n────────────────────────────────────────────────────────────────────────\n(Intercept)   9.48238    0.327089  28.99    0.0220    5.32632   13.6384\nshift_1       3.9096     0.46862    8.34    0.0759   -2.04479    9.86399\nshift_8      -2.4179     0.422825  -5.72    0.1102   -7.7904     2.95461\n────────────────────────────────────────────────────────────────────────\nLog Likelihood: 1.8937302027\nAIC: 4.2125395947\n\nNext we illustrate the model with heterosis, aka transgressive evolution: with a shift in the trait after successful hybridization. First how to simulated according to this model:\n\njulia> nodes_hybrids = indexin([5], [n.number for n in net.node]); # Put a shift on edges below hybrids\n\njulia> params = ParamsBM(10, 0.1, ShiftNet(net.node[nodes_hybrids], [3.0],  net));\n\njulia> using Random; Random.seed!(2468); # sets the seed for reproducibility\n\njulia> sim = rand(net, params); # simulate a dataset with shifts\n\njulia> dat = DataFrame(trait = sim[:tips], tipnames = sim.M.tipnames);\n\nand next how to analyze data under a transgressive evolution model. Below we hard-code data values for more reproducibility.\n\njulia> dat = DataFrame(trait = [10.391976856737717, 9.55741491696386, 10.17703734817448, 12.689062527849698],\n          tipnames = [\"A\",\"B\",\"C\",\"D\"])\n4×2 DataFrame\n Row │ trait     tipnames \n     │ Float64   String   \n─────┼────────────────────\n   1 │ 10.392    A\n   2 │  9.55741  B\n   3 │ 10.177    C\n   4 │ 12.6891   D\n\njulia> dfr_hybrid = descendencedataframe(net) # the regressors matching the hybrids (all of them)\n4×3 DataFrame\n Row │ shift_6  tipnames  sum     \n     │ Float64  String    Float64 \n─────┼────────────────────────────\n   1 │     0.0  A             0.0\n   2 │     0.0  B             0.0\n   3 │     0.0  C             0.0\n   4 │     1.0  D             1.0\n\njulia> dfr = innerjoin(dat, dfr_hybrid, on=:tipnames); # join data and regressors in a single dataframe\n\njulia> using StatsModels\n\njulia> fitBM = phylolm(@formula(trait ~ shift_6), dfr, net; reml=false) # actual fit\nPhyloNetworkLinearModel\n\nFormula: trait ~ 1 + shift_6\n\nModel: Brownian motion\n\nParameter Estimates, using ML:\nphylogenetic variance rate: 0.041206\n\nCoefficients:\n────────────────────────────────────────────────────────────────────────\n                Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n────────────────────────────────────────────────────────────────────────\n(Intercept)  10.064      0.277959  36.21    0.0008    8.86805   11.26\nshift_6       2.72526    0.315456   8.64    0.0131    1.36796    4.08256\n────────────────────────────────────────────────────────────────────────\nLog Likelihood: -0.7006021946\nAIC: 7.4012043891\n\nSee also\n\nphylolm, PhyloNetworks.descendencematrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.empiricalDNAfrequencies","page":"public","title":"PhyloTraits.empiricalDNAfrequencies","text":"empiricalDNAfrequencies(DNAdata::AbstractDataFrame, DNAweights,\n                        correction=true, useambiguous=true)\n\nEstimate base frequencies in DNA data DNAdata, ordered ACGT.\n\nDNAdata: data frame. All columns are used. If the first column gives species names, find a way to ignore it before calculating empirical frequencies, e.g. empiricalDNAfrequencies(view(DNAdata, :, 2:size(DNAdata, 2))). Data type must be BioSymbols.DNA or Char or String. WARNING: this is checked on the first column only.\nDNAweights: vector of weights, to weigh each column in DNAdata.\ncorrection: if true, add 1 to each count and 4 to the denominator for a more stable estimator, similar to Bayes prior of 1/4 and the Agresti-Coull interval in binomial estimation.\nuseambiguous: if true, ambiguous bases are used (except gaps and Ns). For example, Y adds 0.5 weight to C and 0.5 weight to T.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloTraits.fitdiscrete-Tuple{PhyloNetworks.HybridNetwork, PhyloTraits.SubstitutionModel, Dict}","page":"public","title":"PhyloTraits.fitdiscrete","text":"fitdiscrete(net, model, tipdata)\nfitdiscrete(net, model, RateVariationAcrossSites, tipdata)\nfitdiscrete(net, model, species, traits)\nfitdiscrete(net, model, RateVariationAcrossSites, species, traits)\nfitdiscrete(net, model, dnadata, dnapatternweights)\nfitdiscrete(net, model, RateVariationAcrossSites, dnadata, dnapatternweights)\nfitdiscrete(net, modSymbol, species, traits)\nfitdiscrete(net, modSymbol, dnadata, dnapatternweights)\n\nCalculate the maximum likelihood (ML) score of a network or tree given one or more discrete characters at the tips. Along each edge, transitions are modelled with a continous time Markov model, whose parameters are estimated (by maximizing the likelihood). At each hybrid node, the trait is assumed to be inherited from either of the two immediate parents according to the parents' average genetic contributions (inheritance γ). The model ignores incomplete lineage sorting. The algorithm extracts all trees displayed in the network.\n\nData can given in one of the following:\n\ntipdata: dictionary taxon => state label, for a single trait.\ntipdata: data frame for a single trait, in which case the taxon names are to appear in column 1 or in a column named \"taxon\" or \"species\", and trait labels are to appear in column 2 or in a column named \"trait\". Here, trait labels should be as they appear in getlabels(model).\nspecies: vector of strings, and traits: DataFrame of traits, with rows in the order corresponding to the order of species names. Again, trait labels should be as they appear in getlabels(model). All traits are assumed to follow the same model, with same parameters.\ndnadata: the first part of the output of readfastatodna, a dataframe of BioSequence DNA sequences, with taxon in column 1 and a column for each site.\ndnapatternweights: the second part of the output of readfastatodna, an array of weights, one weights for each of the site columns. The length of the weight is equal to nsites. If using dnapatternweights, must provide dnadata.\nRateVariationAcrossSites: model for rate variation (optional)\n\nOptional arguments (default):\n\noptimizeQ (true): should model rate parameters be fixed, or should they be optimized?\noptimizeRVAS (true): should the model optimize the parameters for the variability of rates across sites (α and/or p_invariable)?\nNLoptMethod (:LN_COBYLA, derivative-free) for the optimization algorithm. For other options, see the NLopt.\ntolerance values to control when the optimization is stopped: ftolRel (1e-12), ftolAbs (1e-10) on the likelihood, and xtolRel (1e-10), xtolAbs (1e-10) on the model parameters.\nbounds for the alpha parameter of the Gamma distribution of rates across sites: alphamin=0.05, alphamax=50.\nverbose (false): if true, more information is output.\nsuppresswarnings (false): if true, warnings from check_matchtaxonnames! are suppressed.\n\nexamples:\n\njulia> net = readnewick(\"(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [\"lo\", \"hi\"]);\n\njulia> using DataFrames\n\njulia> dat = DataFrame(species=[\"C\",\"A\",\"B\",\"D\"], trait=[\"hi\",\"lo\",\"lo\",\"hi\"]);\n\njulia> fit1 = fitdiscrete(net, m1, dat)\nPhyloTraits.StatisticalSubstitutionModel:\nBinary Trait Substitution Model:\n  rate lo→hi α=0.27222\n  rate hi→lo β=0.34981\non a network with 1 reticulations\ndata:\n  4 species\n  1 trait\nlog-likelihood: -2.7277\n\njulia> tips = Dict(\"A\" => \"lo\", \"B\" => \"lo\", \"C\" => \"hi\", \"D\" => \"hi\");\n\njulia> fit2 = fitdiscrete(net, m1, tips; xtolRel=1e-16, xtolAbs=1e-16, ftolRel=1e-16)\nPhyloTraits.StatisticalSubstitutionModel:\nBinary Trait Substitution Model:\n  rate lo→hi α=0.27222\n  rate hi→lo β=0.34981\non a network with 1 reticulations\ndata:\n  4 species\n  1 trait\nlog-likelihood: -2.7277\n\nNote that a copy of the network is stored in the fitted object, but the internal representation of the network may be different in fit1.net and in the original network net:\n\njulia> net = readnewick(\"(sp1:3.0,(sp2:2.0,(sp3:1.0,sp4:1.0):1.0):1.0);\");\n\njulia> using BioSymbols\n\njulia> tips = Dict(\"sp1\" => BioSymbols.DNA_A, \"sp2\" => BioSymbols.DNA_A, \"sp3\" => BioSymbols.DNA_G, \"sp4\" => BioSymbols.DNA_G);\n\njulia> mJC69 = JC69([0.25], false);\n\njulia> fitJC69 = fitdiscrete(net, mJC69, tips)\nPhyloTraits.StatisticalSubstitutionModel:\nJukes and Cantor 69 Substitution Model,\n  absolute rate version\n  off-diagonal rates equal to 0.29233/3.\n  rate matrix Q:\n                 A       C       G       T\n         A       *  0.0974  0.0974  0.0974\n         C  0.0974       *  0.0974  0.0974\n         G  0.0974  0.0974       *  0.0974\n         T  0.0974  0.0974  0.0974       *\non a network with 0 reticulations\ndata:\n  4 species\n  1 trait\nlog-likelihood: -4.99274\n\njulia> rv = RateVariationAcrossSites(alpha=1.0, ncat=4)\nRate variation across sites: discretized Gamma\nalpha: 1.0\ncategories for Gamma discretization: 4\nrates: [0.146, 0.513, 1.071, 2.27]\n\njulia> fitdiscrete(net, mJC69, rv, tips; optimizeQ=false, optimizeRVAS=false)\nPhyloTraits.StatisticalSubstitutionModel:\nJukes and Cantor 69 Substitution Model,\n  absolute rate version\n  off-diagonal rates equal to 0.25/3.\n  rate matrix Q:\n                 A       C       G       T\n         A       *  0.0833  0.0833  0.0833\n         C  0.0833       *  0.0833  0.0833\n         G  0.0833  0.0833       *  0.0833\n         T  0.0833  0.0833  0.0833       *\nRate variation across sites: discretized Gamma\n  alpha: 1.0\n  categories for Gamma discretization: 4\n  rates: [0.146, 0.513, 1.071, 2.27]\non a network with 0 reticulations\ndata:\n  4 species\n  1 trait\nlog-likelihood: -5.2568\n\n\nfixit: add option to allow users to specify root prior, using either equal frequencies or stationary frequencies for trait models.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.getlabels-Tuple{PhyloTraits.NucleicAcidSubstitutionModel}","page":"public","title":"PhyloTraits.getlabels","text":"for a given NucleicAcidSubstitutionModel, labels are symbols from BioSymbols. For now, only ACGTs are allowed. (When fitting data, any ambiguity code in the data would be treated as missing value).\n\nexamples\n\njulia> getlabels(JC69([0.03], false))\n4-element Vector{BioSymbols.DNA}:\n DNA_A\n DNA_C\n DNA_G\n DNA_T\n\njulia> getlabels(HKY85([.5], repeat([0.25], 4)))\n4-element Vector{BioSymbols.DNA}:\n DNA_A\n DNA_C\n DNA_G\n DNA_T\n\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.getlabels-Tuple{PhyloTraits.SubstitutionModel}","page":"public","title":"PhyloTraits.getlabels","text":"getlabels(model)\n\nState labels of a substitution model.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.getshiftedgenumber-Tuple{ShiftNet}","page":"public","title":"PhyloTraits.getshiftedgenumber","text":"getshiftedgenumber(shift::ShiftNet)\n\nGet the edge numbers where the shifts are located, for an object ShiftNet. If a shift is placed at the root node with no parent edge, the edge number of a shift is set to -1 (as if missing).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.getshiftvalue-Tuple{ShiftNet}","page":"public","title":"PhyloTraits.getshiftvalue","text":"getshiftvalue(shift::ShiftNet)\n\nGet the values of the shifts, for an object ShiftNet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.lambda_estim-Tuple{PhyloNetworkLinearModel}","page":"public","title":"PhyloTraits.lambda_estim","text":"lambda_estim(m::PhyloNetworkLinearModel)\n\nEstimated lambda parameter for a fitted object.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.mu_phylo-Tuple{PhyloNetworkLinearModel}","page":"public","title":"PhyloTraits.mu_phylo","text":"mu_phylo(m::PhyloNetworkLinearModel)\n\nEstimated root value for a fitted object.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.nparams-Tuple{HKY85}","page":"public","title":"PhyloTraits.nparams","text":"for HKY85 model: 1 if relative, 2 if absolute\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.nparams-Tuple{JC69}","page":"public","title":"PhyloTraits.nparams","text":"for JC69 model: 0 if relative, 1 if absolute\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.nparams-Tuple{PhyloTraits.SubstitutionModel}","page":"public","title":"PhyloTraits.nparams","text":"nparams(model)\n\nNumber of parameters for a given trait evolution model (length of field model.rate).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.nstates-Tuple{BinaryTraitSubstitutionModel}","page":"public","title":"PhyloTraits.nstates","text":"for a BinaryTraitSubstitutionModel, this is 2:\n\njulia> m1 = BinaryTraitSubstitutionModel([1.0,2.0], [\"low\",\"high\"])\nBinary Trait Substitution Model:\nrate low→high α=1.0\nrate high→low β=2.0\n\njulia> nstates(m1)\n2\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.nstates-Tuple{PhyloTraits.NucleicAcidSubstitutionModel}","page":"public","title":"PhyloTraits.nstates","text":"For example, this is 4 for a NucleicAcidSubstitutionModel.\n\njulia> nstates(JC69([0.03], false))\n4\n\njulia> nstates(HKY85([.5], [0.25, 0.25, 0.25, 0.25]))\n4\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.nstates-Tuple{PhyloTraits.SubstitutionModel}","page":"public","title":"PhyloTraits.nstates","text":"nstates(model)\n\nNumber of character states for a given evolution model.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.phylolm","page":"public","title":"PhyloTraits.phylolm","text":"phylolm(X::Matrix, Y::Vector, net::HybridNetwork, model::ContinuousTraitEM=BM(); kwargs...)\n\nReturn a PhyloNetworkLinearModel object. This method is called by phylolm(formula, data, network; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PhyloTraits.phylolm-Tuple{StatsModels.FormulaTerm, DataFrames.AbstractDataFrame, PhyloNetworks.HybridNetwork}","page":"public","title":"PhyloTraits.phylolm","text":"phylolm(f::StatsModels.FormulaTerm, fr::AbstractDataFrame, net::HybridNetwork; kwargs...)\n\nFit a phylogenetic linear regression model to data. Return an object of type PhyloNetworkLinearModel. It contains a linear model from the GLM package, in object.lm, of type GLM.LinearModel.\n\nArguments\n\nf: formula to use for the regression, see StatsModels\nfr: DataFrame containing the response values, predictor values, species/tip labels for each observation/row.\nnet: phylogenetic network to use. Should have labelled tips.\n\nKeyword arguments\n\nmodel=\"BM\": model for trait evolution (as a string) \"lambda\" (Pagel's lambda), \"scalinghybrid\" are other possible values (see ContinuousTraitEM)\ntipnames=:tipnames: column name for species/tip-labels, represented as a symbol. For example, if the column containing the species/tip labels in fr is named \"Species\", then do tipnames=:Species.\nno_names=false: If true, force the function to ignore the tips names. The data is then assumed to be in the same order as the tips of the network. Default is false, setting it to true is dangerous, and strongly discouraged.\nreml=true: if true, use REML criterion (\"restricted maximum likelihood\") for estimating variance components, else use ML criterion.\nsuppresswarnings=false: if true, PhyloTraits-specific warnings are suppressed. Currently, only Pagel's lambda model may throw a warning (if the network is not time-consistent).\n\nThe following tolerance parameters control the optimization of lambda if model=\"lambda\" or model=\"scalinghybrid\", and control the optimization of the variance components if model=\"BM\" and withinspecies_var=true.\n\nfTolRel=1e-10: relative tolerance on the likelihood value\nfTolAbs=1e-10: absolute tolerance on the likelihood value\nxTolRel=1e-10: relative tolerance on the parameter value\nxTolAbs=1e-10: absolute tolerance on the parameter value\nstartingValue=0.5: If model=\"lambda\" or \"scalinghybrid\", this provides the starting value for the optimization in lambda.\nfixedValue=missing: If model=\"lambda\" or \"scalinghybrid\", and fixedValue is a number, then lambda is set to this number and is not optimized.\nwithinspecies_var=false: If true, fits a within-species variation model. Currently only implemented for model=\"BM\".\ny_mean_std::Bool=false: If true, and withinspecies_var=true, then accounts for within-species variation, using species-level statistics provided in fr.\n\nMethods applied to fitted models\n\nTo access the response values, do response(object). To access the model matrix, do modelmatrix(object). To access the model formula, do formula(object).\n\nWithin-species variation\n\nFor a high-level description, see PhyloNetworkLinearModel. To fit a model with within-species variation in the response variable, either of the following must be provided in the data frame fr:\n\n(1) Individual-level data: There should be columns for response, predictors, and species/tip-labels. Every row should correspond to an individual observation. At least one species must be represented by two or more individuals.\n\n(2) Species-level statistics: There should be columns for mean response, predictors, species/tip-labels, species sample-sizes (number of individuals for each species), and species standard deviations (standard deviations of the response values by species). Every row should correspond to a species: each species should be represented by a unique row. The column names for species sample-sizes and species standard deviations are expected to be \"[response column name]_n\" and \"[response column name]_sd\". For example, if the response column name is \"y\", then the column names should be \"y_n\" and \"y_sd\" for the sample-sizes and standard deviations.\n\nRegardless of whether the data provided follows (1) or (2), withinspecies_var should be set to true. If the data provided follows (2), then y_mean_std should be set to false.\n\nWithin-species variation in predictors\n\nThe model assumes no within-species variation in predictors, because it aims to capture the evolutionary (historical, phylogenetic) relationship between the predictors and the response, not the within-species (present-day, or phenotypic) relationship.\n\nIf a within-species variation model is fitted on individual-level data, and if there are individuals within the same species with different values for the same predictor, these values are all replaced by the mean predictor value for all the individuals in that species. For example, suppose there are 3 individuals in a given species, and that their predictor values are (x₁=3, x₂=6), (x₁=4, x₂=8) and (x₁=2, x₂=1). Then the predictor values for these 3 individuals are each replaced by (x₁=(3+4+2)/3, x₂=(6+8+1)/3) before model fitting. If a fourth individual had data (x₁=10, x₂=missing), then that individual would be ignored for any model using x₂, and would not contribute any information to its species data for these models.\n\nMissing data\n\nRows with missing data for either the response or the predictors are omitted from the model-fitting. There should minimally be columns for response, predictors, species/tip-labels. As detailed above, additional columns may be required for fitting within-species variation. Missing data in the columns for species names, species standard deviation / sample sizes (if used) will throw an error.\n\nSee also\n\nrand, ancestralreconstruction, PhyloNetworks.vcv\n\nExamples: Without within-species variation\n\nWe first load data from the package and fit the default BM model.\n\njulia> phy = readnewick(joinpath(dirname(pathof(PhyloTraits)), \"..\", \"examples\", \"caudata_tree.txt\"));\n\njulia> using DataFrames, CSV # to read data file, next\n\njulia> dat = CSV.read(joinpath(dirname(pathof(PhyloTraits)), \"..\", \"examples\", \"caudata_trait.txt\"), DataFrame);\n\njulia> using StatsModels # for stat model formulas\n\njulia> fitBM = phylolm(@formula(trait ~ 1), dat, phy; reml=false);\n\njulia> fitBM # Shows a summary\nPhyloNetworkLinearModel\n\nFormula: trait ~ 1\n\nModel: Brownian motion\n\nParameter Estimates, using ML:\nphylogenetic variance rate: 0.00294521\n\nCoefficients:\n─────────────────────────────────────────────────────────────────────\n             Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n─────────────────────────────────────────────────────────────────────\n(Intercept)  4.679    0.330627  14.15    <1e-31    4.02696    5.33104\n─────────────────────────────────────────────────────────────────────\nLog Likelihood: -78.9611507833\nAIC: 161.9223015666\n\nWe can extra parameters, likelihood, AIC etc.\n\njulia> round(sigma2_phylo(fitBM), digits=6) # rounding for jldoctest convenience\n0.002945\n\njulia> round(mu_phylo(fitBM), digits=4)\n4.679\n\njulia> using StatsBase # for aic() stderror() loglikelihood() etc.\n\njulia> round(loglikelihood(fitBM), digits=10)\n-78.9611507833\n\njulia> round(aic(fitBM), digits=10)\n161.9223015666\n\njulia> round(aicc(fitBM), digits=10)\n161.9841572367\n\njulia> round(bic(fitBM), digits=10)\n168.4887090241\n\njulia> round.(coef(fitBM), digits=4)\n1-element Vector{Float64}:\n 4.679\n\njulia> confint(fitBM) # 95% (default) confidence interval for the coefficient(s)\n1×2 Matrix{Float64}:\n 4.02696  5.33104\n\njulia> abs(round(r2(fitBM), digits=10)) # absolute value for jldoctest convenience\n0.0\n\njulia> abs(round(adjr2(fitBM), digits=10))\n0.0\n\njulia> round.(vcov(fitBM), digits=6) # variance-covariance of estimated parameters: squared standard error\n1×1 Matrix{Float64}:\n 0.109314\n\nThe residuals are the variance not explained by predictors. The phylogenetic correlation modelled by the BM is about them. The trait may have 2 sources of phylogenetic signal: from the predictor with which it the response may be associated, and from the residuals.\n\njulia> round.(residuals(fitBM), digits=6)\n197-element Vector{Float64}:\n -0.237648\n -0.357937\n -0.159387\n -0.691868\n -0.323977\n -0.270452\n -0.673486\n -0.584654\n -0.279882\n -0.302175\n  ⋮\n -0.777026\n -0.385121\n -0.443444\n -0.327303\n -0.525953\n -0.673486\n -0.603158\n -0.211712\n -0.439833\n\njulia> round.(response(fitBM), digits=5)\n197-element Vector{Float64}:\n 4.44135\n 4.32106\n 4.51961\n 3.98713\n 4.35502\n 4.40855\n 4.00551\n 4.09434\n 4.39912\n 4.37682\n ⋮\n 3.90197\n 4.29388\n 4.23555\n 4.3517\n 4.15305\n 4.00551\n 4.07584\n 4.46729\n 4.23917\n\njulia> round.(predict(fitBM), digits=5)\n197-element Vector{Float64}:\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n ⋮\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n 4.679\n\nExamples: With within-species variation (two different input formats shown)\n\nWe use a smaller network here. We can input data as 1 row per individual, multiple rows per species:\n\njulia> net = readnewick(\"((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\");\n\njulia> df = DataFrame( # individual-level observations\n           species = repeat([\"D\",\"C\",\"A\",\"B\",\"E\",\"O\"],inner=3),\n           trait1 = [4.08298,4.08298,4.08298,3.10782,3.10782,3.10782,2.17078,2.17078,2.17078,1.87333,1.87333,\n              1.87333,2.8445,2.8445,2.8445,5.88204,5.88204,5.88204],\n           trait2 = [-7.34186,-7.34186,-7.34186,-7.45085,-7.45085,-7.45085,-3.32538,-3.32538,-3.32538,-4.26472,\n              -4.26472,-4.26472,-5.96857,-5.96857,-5.96857,-1.99388,-1.99388,-1.99388],\n           trait3 = [18.8101,18.934,18.9438,17.0687,17.0639,17.0732,14.4818,14.1112,14.2817,13.0842,12.9562,\n              12.9019,15.4373,15.4075,15.4317,24.2249,24.1449,24.1302]);\n\njulia> m1 = phylolm(@formula(trait3 ~ trait1), df, net;\n                    tipnames=:species, withinspecies_var=true)\nPhyloNetworkLinearModel\n\nFormula: trait3 ~ 1 + trait1\n\nModel: Brownian motion\n\nParameter Estimates, using REML:\nphylogenetic variance rate: 0.156188\nwithin-species variance: 0.0086343\n\nCoefficients:\n──────────────────────────────────────────────────────────────────────\n               Coef.  Std. Error     t  Pr(>|t|)  Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────\n(Intercept)  9.65347    1.3066    7.39    0.0018    6.02577   13.2812\ntrait1       2.30358    0.276163  8.34    0.0011    1.53683    3.07033\n──────────────────────────────────────────────────────────────────────\nLog Likelihood: 1.9446255188\nAIC: 4.1107489623\n\nAlternatively, we can input the data as 1 row per species and 2 extra columns: standard deviation of the response trait among individuals in the same species, and number of individuals per species for which we calculated this SD. The result is the same.\n\njulia> df_r = DataFrame( # species-level statistics (sample means, standard deviations)\n           species = [\"D\",\"C\",\"A\",\"B\",\"E\",\"O\"],\n           trait1 = [4.08298,3.10782,2.17078,1.87333,2.8445,5.88204],\n           trait2 = [-7.34186,-7.45085,-3.32538,-4.26472,-5.96857,-1.99388],\n           trait3 = [18.896,17.0686,14.2916,12.9808,15.4255,24.1667],\n           trait3_sd = [0.074524,0.00465081,0.185497,0.0936,0.0158379,0.0509643],\n           trait3_n = [3, 3, 3, 3, 3, 3]);\n\njulia> m2 = phylolm(@formula(trait3 ~ trait1), df_r, net;\n                tipnames=:species, withinspecies_var=true, y_mean_std=true)\nPhyloNetworkLinearModel\n\nFormula: trait3 ~ 1 + trait1\n\nModel: Brownian motion\n\nParameter Estimates, using REML:\nphylogenetic variance rate: 0.15618\nwithin-species variance: 0.0086343\n\nCoefficients:\n──────────────────────────────────────────────────────────────────────\n               Coef.  Std. Error     t  Pr(>|t|)  Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────\n(Intercept)  9.65342    1.30657   7.39    0.0018    6.02582   13.281\ntrait1       2.30359    0.276156  8.34    0.0011    1.53686    3.07032\n──────────────────────────────────────────────────────────────────────\nLog Likelihood: 1.9447243714\nAIC: 4.1105512573\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.shiftathybrids-Tuple{VecOrMat{T} where T<:Real, PhyloNetworks.HybridNetwork}","page":"public","title":"PhyloTraits.shiftathybrids","text":"shiftathybrids(value::Vector{T} where T<:Real, net::HybridNetwork; checkpreorder::Bool=true)\n\nConstruct an object ShiftNet with shifts on all the edges below hybrid nodes, with values provided. The vector of values must have the same length as the number of hybrids in the network.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.sigma2_phylo-Tuple{PhyloNetworkLinearModel}","page":"public","title":"PhyloTraits.sigma2_phylo","text":"sigma2_phylo(m::PhyloNetworkLinearModel)\n\nEstimated between-species variance-rate for a fitted object.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.sigma2_within-Tuple{PhyloNetworkLinearModel}","page":"public","title":"PhyloTraits.sigma2_within","text":"sigma2_within(m::PhyloNetworkLinearModel)\n\nEstimated within-species variance for a fitted object.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.stationary-Tuple{PhyloTraits.SubstitutionModel}","page":"public","title":"PhyloTraits.stationary","text":"stationary(substitutionmodel)\n\nStationary distribution of a Markov model\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Random.rand!-Tuple{Random.AbstractRNG, AbstractVector{Int64}, PhyloTraits.SubstitutionModel, Float64, AbstractVector{Int64}}","page":"public","title":"Random.rand!","text":"rand!(rng::AbstractRNG,\n      end::AbstractVector{Int},\n      model::TraitSubstitutionModel,\n      t::Float64,\n      start::AbstractVector{Int})\n\nSimulate discrete traits along one edge of length t like rand, but modifying end in place to store the simulated values.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.BinaryTraitSubstitutionModel","page":"public","title":"PhyloTraits.BinaryTraitSubstitutionModel","text":"BinaryTraitSubstitutionModel(α, β [, label])\n\nModel for binary traits, that is, with 2 states. Default labels are \"0\" and \"1\". α is the rate of transition from \"0\" to \"1\", and β from \"1\" to \"0\".\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.EqualRatesSubstitutionModel","page":"public","title":"PhyloTraits.EqualRatesSubstitutionModel","text":"EqualRatesSubstitutionModel(numberStates, α, labels)\n\nTraitSubstitutionModel for traits with any number of states and equal substitution rates α between all states. Default labels are \"1\",\"2\",...\n\nexample\n\njulia> m1 = EqualRatesSubstitutionModel(2, [1.0], [\"low\",\"high\"])\nEqual Rates Substitution Model with k=2,\nall rates equal to α=1.0.\nrate matrix Q:\n             low    high\n     low       *  1.0000\n    high  1.0000       *\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.HKY85","page":"public","title":"PhyloTraits.HKY85","text":"HKY85(rate, pi, relative)\n\nA nucleic acid substitution model based on Hasegawa et al. 1985 substitution model. rate should be a vector of 1 or 2 rates, and pi a vector of 4 probabilities summing to 1.\n\nIf relative is false, the 2 rates represent the transition rate and the transversion rate, α and β. If relative is true (default), only the first rate is used and represents the transition/transversion ratio: κ=α/β. The rate transition matrix Q is normalized to have 1 change / unit of time on average, i.e. the absolute version of Q is divided by 2(piT*piC + piA*piG)α + 2(piY*piR)β.\n\nnparams returns 1 or 2. In other words: the stationary distribution is not counted in the number of parameters (and fitdiscrete does not optimize the pi values at the moment).\n\nexamples\n\njulia> m1 = HKY85([.5], [0.20, 0.30, 0.30, 0.20])\nHKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]\nrelative rate version with transition/tranversion ratio kappa = 0.5,\n scaled so that there is one substitution per unit time\nrate matrix Q:\n               A       C       G       T\n       A       *  0.4839  0.2419  0.3226\n       C  0.3226       *  0.4839  0.1613\n       G  0.1613  0.4839       *  0.3226\n       T  0.3226  0.2419  0.4839       *\n\njulia> nstates(m1)\n4\n\njulia> m2 = HKY85([0.5, 0.5], [0.20, 0.30, 0.30, 0.20], false)\nHKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]\nabsolute rate version with transition/transversion ratio kappa = a/b = 1.0\n with rates a = 0.5 and b = 0.5\nrate matrix Q:\n               A       C       G       T\n       A       *  0.1500  0.1500  0.1000\n       C  0.1000       *  0.1500  0.1000\n       G  0.1000  0.1500       *  0.1000\n       T  0.1000  0.1500  0.1500       *\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.JC69","page":"public","title":"PhyloTraits.JC69","text":"JC69(rate, relative)\n\nJukes Cantor (1969) nucleic acid substitution model, which has a single rate parameter. rate corresponds to the absolute diagonal elements, that is, the rate of change (to any of the other 2 states). Individual rates are rate/3. If relative is true (default), the transition matrix Q is normalized to an average of 1 transition per unit of time: in which case rate is set to 1.0.\n\nexamples\n\njulia> m1 = JC69([0.25], false)\nJukes and Cantor 69 Substitution Model,\nabsolute rate version\noff-diagonal rates equal to 0.25/3.\nrate matrix Q:\n               A       C       G       T\n       A       *  0.0833  0.0833  0.0833\n       C  0.0833       *  0.0833  0.0833\n       G  0.0833  0.0833       *  0.0833\n       T  0.0833  0.0833  0.0833       *\n\njulia> nstates(m1)\n4\n\njulia> nparams(m1)\n1\n\njulia> m2 = JC69([0.5])\nJukes and Cantor 69 Substitution Model,\nrelative rate version\noff-diagonal rates equal to 1/3\nrate matrix Q:\n               A       C       G       T\n       A       *  0.3333  0.3333  0.3333\n       C  0.3333       *  0.3333  0.3333\n       G  0.3333  0.3333       *  0.3333\n       T  0.3333  0.3333  0.3333       *\n\njulia> nparams(m2)\n0\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.ParamsBM","page":"public","title":"PhyloTraits.ParamsBM","text":"ParamsBM <: ParamsProcess\n\nType for a BM process on a network. Fields are mu (expectation), sigma2 (variance), randomRoot (whether the root is random, default to false), and varRoot (if the root is random, the variance of the root, default to NaN).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.ParamsMultiBM","page":"public","title":"PhyloTraits.ParamsMultiBM","text":"ParamsMultiBM <: ParamsProcess\n\nType for a multivariate Brownian diffusion (MBD) process on a network. Fields are mu (expectation), sigma (covariance matrix), randomRoot (whether the root is random, default to false), varRoot (if the root is random, the covariance matrix of the root, default to [NaN]), shift (a ShiftNet type, default to missing), and L (the lower triangular of the cholesky decomposition of sigma, computed automatically)\n\nexamples and constructors\n\njulia> ParamsMultiBM([1.0, -0.5], [2.0 0.3; 0.3 1.0]) # no shifts\nParamsMultiBM:\nParameters of a MBD with fixed root:\nmu: [1.0, -0.5]\nSigma: [2.0 0.3; 0.3 1.0]\n\njulia> net = readnewick(\"((A:1,B:1):1,C:2);\");\n\njulia> shifts = ShiftNet(net.node[2], [-1.0, 2.0], net);\n\njulia> ParamsMultiBM([1.0, -0.5], [2.0 0.3; 0.3 1.0], shifts) # with shifts\nParamsMultiBM:\nParameters of a MBD with fixed root:\nmu: [1.0, -0.5]\nSigma: [2.0 0.3; 0.3 1.0]\n\nThere are 2 shifts on the network:\n───────────────────────────────────────────\n  Edge Number  Shift Value 1  Shift Value 2\n───────────────────────────────────────────\n          2.0           -1.0            2.0\n───────────────────────────────────────────\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.PhyloNetworkLinearModel","page":"public","title":"PhyloTraits.PhyloNetworkLinearModel","text":"PhyloNetworkLinearModel <: GLM.LinPredModel\n\nPhylogenetic linear model representation.\n\nFields\n\nlm, V, Vy, RL, Y, X, logdetVy, reml, ind, nonmissing, evomodel, model_within and formula. The following syntax pattern can be used to get more information on a specific field: e.g. to find out about the lm field, do ?PhyloNetworkLinearModel.lm.\n\nMethods applied to fitted models\n\nThe following StatsAPI / StatsBase functions can be applied: coef, nobs, vcov, stderror, confint, coeftable, dof_residual, dof, deviance, residuals, response, predict, loglikelihood, nulldeviance, nullloglikelihood, r2, adjr2, aic, aicc, bic, ftest, lrtest etc.\n\nThe estimated variance-rate and estimated mean of the species-level trait model (see ContinuousTraitEM) can be retrieved using sigma2_phylo and mu_phylo respectively.\n\nIf relevant, the estimated individual-level/within-species variance can be retrieved using sigma2_within.\n\nThe optimized λ parameter for Pagel's λ model (see PagelLambda) can be retrieved using lambda_estim.\n\nAn ancestral state reconstruction can be performed using ancestralreconstruction.\n\nWithin-species variation\n\nThe true species/population means for the response trait/variable (or the residuals: conditional on the predictors) are jointly modeled as 𝒩(·, σ²ₛV) where V depends on the trait model (see ContinuousTraitEM) and on the species network. σ²ₛ is the between-species variance-rate.\n\nWithin-species variation is modeled by assuming that the individual-level responses are iid 𝒩(0, σ²ₑ) about the true species means, so that the species-level sample means (conditional on the predictors) are jointly modeled as 𝒩(·, σ²ₛV + σ²ₑD⁻¹), where σ²ₑ is the within-species variance and D⁻¹ is a diagonal matrix whose entries are the inverse sample-sizes (see WithinSpeciesCTM).\n\nAlthough the above two models can be expressed in terms of a joint distribution for the species-level sample means (or residuals conditional on the predictors), more data are required to fit a model accounting for within-species variation, that is, a model recognizing that the sample means are estimates of the true population means. To fit a model without within-species variation, data on the species means are sufficient. To fit a model with within-species variation, we need to have the species means and the standard deviations of the response variable for each species.\n\nphylolm can fit a model with within-species variation either from species-level statistics (\"mean response\" and \"standard deviation in response\") or from individual-level data (in which case the species-level statistics are computed internally). See phylolm for more details on these two input choices.\n\nIn the object, obj.Y and obj.X are the observed species means. predict, residuals and response return the values at the species level.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.RateVariationAcrossSites","page":"public","title":"PhyloTraits.RateVariationAcrossSites","text":"RateVariationAcrossSites(rvsymbol::Symbol, ncategories::Int=4)\n\nDefault model for rate variation across site, specified by a symbol:\n\n:noRV for no rate variation\n:G or :Gamma for gamma-distributed rates\n:I or :Inv for two categories: invariable and variable\n:GI or :GI for both.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.RateVariationAcrossSites-Tuple{}","page":"public","title":"PhyloTraits.RateVariationAcrossSites","text":"RateVariationAcrossSites(; pinv=0.0, alpha=Inf, ncat=4)\n\nModel for variable substitution rates across sites (or across traits) using the discrete Gamma model (+G, Yang 1994, Journal of Molecular Evolution) or the invariable-sites model (+I, Hasegawa, Kishino & Yano 1985 J Mol Evol). Both types of rate variation can be combined (+G+I, Gu, Fu & Li 1995, Mol Biol Evol) but this is discouraged (Jia, Lo & Ho 2014 PLOS One). Using rate variation increases the number of parameters by one (+G or +I) or by two (+G+I).\n\nBecause the mean of the desired distribution or rates is 1, we use a Gamma distribution with shape α and scale θ=1/α (rate β=α) if no invariable sites, or scale θ=1/(α(1-pinv)), that is rate β=α(1-pinv) with a proportion pinv of invariable sites. The shape parameter is referred to as alpha here. The Gamma distribution is discretized into ncat categories. In each category, the category's rate multiplier is a normalized quantile of the gamma distribution.\n\njulia> rv = RateVariationAcrossSites()\nRate variation across sites: discretized Gamma\ncategories for Gamma discretization: 1\nrates: [1.0]\n\njulia> nparams(rv)\n0\n\njulia> typeof(rv)\nPhyloTraits.RVASGamma{1}\n\njulia> rv = RateVariationAcrossSites(alpha=1.0, ncat=4)\nRate variation across sites: discretized Gamma\nalpha: 1.0\ncategories for Gamma discretization: 4\nrates: [0.146, 0.513, 1.071, 2.27]\n\njulia> typeof(rv)\nPhyloTraits.RVASGamma{4}\n\njulia> PhyloTraits.setalpha!(rv, 2.0)\nRate variation across sites: discretized Gamma\nalpha: 2.0\ncategories for Gamma discretization: 4\nrates: [0.319, 0.683, 1.109, 1.889]\n\njulia> nparams(rv)\n1\n\njulia> rv = RateVariationAcrossSites(pinv=0.3)\nRate variation across sites: +I (invariable sites)\npinv: 0.3\nrates: [0.0, 1.429]\n\njulia> nparams(rv)\n1\n\njulia> typeof(rv)\nPhyloTraits.RVASInv\n\njulia> PhyloTraits.setpinv!(rv, 0.05)\nRate variation across sites: +I (invariable sites)\npinv: 0.05\nrates: [0.0, 1.053]\n\njulia> rv = RateVariationAcrossSites(pinv=0.3, alpha=2.0, ncat=4)\nRate variation across sites: discretized Gamma+I\npinv: 0.3\nalpha: 2.0\ncategories for Gamma discretization: 4\nrates: [0.0, 0.456, 0.976, 1.584, 2.698]\nprobabilities: [0.3, 0.175, 0.175, 0.175, 0.175]\n\njulia> nparams(rv)\n2\n\njulia> typeof(rv)\nPhyloTraits.RVASGammaInv{5}\n\njulia> PhyloTraits.setalpha!(rv, 3.0)\nRate variation across sites: discretized Gamma+I\npinv: 0.3\nalpha: 3.0\ncategories for Gamma discretization: 4\nrates: [0.0, 0.6, 1.077, 1.584, 2.454]\nprobabilities: [0.3, 0.175, 0.175, 0.175, 0.175]\n\njulia> PhyloTraits.setpinv!(rv, 0.05)\nRate variation across sites: discretized Gamma+I\npinv: 0.05\nalpha: 3.0\ncategories for Gamma discretization: 4\nrates: [0.0, 0.442, 0.793, 1.167, 1.808]\nprobabilities: [0.05, 0.238, 0.238, 0.238, 0.238]\n\njulia> PhyloTraits.setpinvalpha!(rv, 0.1, 5.0)\nRate variation across sites: discretized Gamma+I\npinv: 0.1\nalpha: 5.0\ncategories for Gamma discretization: 4\nrates: [0.0, 0.593, 0.91, 1.221, 1.721]\nprobabilities: [0.1, 0.225, 0.225, 0.225, 0.225]\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PhyloTraits.ReconstructedStates","page":"public","title":"PhyloTraits.ReconstructedStates","text":"ReconstructedStates\n\nType containing the inferred information about the law of the ancestral states given the observed tips values. The missing tips are considered as ancestral states.\n\nReconstructed states and prediction intervals can be recovered with function predict, and the standard error can be obtained with stderror.\n\nThe ReconstructedStates object has fields: traits_nodes, variances_nodes, nodenumbers, traits_tips, tipnumbers, model. Type in \"?ReconstructedStates.field\" to get help on a specific field.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.ShiftNet","page":"public","title":"PhyloTraits.ShiftNet","text":"ShiftNet\n\nShifts mapped to tree nodes and their (unique) parent edge on a PhyloNetworks.HybridNetwork sorted in topological order. Its shift field is a vector of shift values, one for each node, corresponding to the shift on the parent edge of the node (which makes sense for tree nodes only: they have a single parent edge).\n\nTwo ShiftNet objects on the same network can be concatened with *.\n\nShiftNet(node::Vector{Node}, value::AbstractVector, net::HybridNetwork; checkpreorder::Bool=true)\n\nConstructor from a vector of nodes and associated values. The shifts are located on the edges above the nodes provided. Warning, shifts on hybrid edges are not allowed.\n\nShiftNet(edge::Vector{Edge}, value::AbstractVector, net::HybridNetwork; checkpreorder::Bool=true)\n\nConstructor from a vector of edges and associated values. Warning, shifts on hybrid edges are not allowed.\n\nExtractors: getshiftedgenumber, getshiftvalue\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.TraitSimulation","page":"public","title":"PhyloTraits.TraitSimulation","text":"TraitSimulation\n\nResult of a trait simulation on an PhyloNetworks.HybridNetwork with rand.\n\nThe following functions and extractors can be applied to it: tiplabels, obj[:tips], obj[:internalnodes] (see documentation for function getindex(::TraitSimulation, ::Symbol)).\n\nThe TraitSimulation object has fields: M, params, evomodel.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.TraitSubstitutionModel","page":"public","title":"PhyloTraits.TraitSubstitutionModel","text":"TraitSubstitutionModel\n\nFor subtypes, see BinaryTraitSubstitutionModel, EqualRatesSubstitutionModel, TwoBinaryTraitSubstitutionModel\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PhyloTraits.TwoBinaryTraitSubstitutionModel","page":"public","title":"PhyloTraits.TwoBinaryTraitSubstitutionModel","text":"TwoBinaryTraitSubstitutionModel(rate [, label])\n\nTraitSubstitutionModel for two binary traits, possibly correlated. Default labels are \"x0\", \"x1\" for trait 1, and \"y0\", \"y1\" for trait 2. If provided, label should be a vector of size 4, listing labels for trait 1 first then labels for trait 2. rate should be a vector of substitution rates of size 8. rate[1],...,rate[4] describe rates of changes in trait 1. rate[5],...,rate[8] describe rates of changes in trait 2. In the transition matrix, trait combinations are listed in the following order: x0-y0, x0-y1, x1-y0, x1-y1.\n\nexample\n\nmodel = TwoBinaryTraitSubstitutionModel([2.0,1.2,1.1,2.2,1.0,3.1,2.0,1.1],\n        [\"carnivory\", \"noncarnivory\", \"wet\", \"dry\"]);\nmodel\nusing PhyloPlots\nplot(model) # to visualize states and rates. not supported with PhyloPlots v2.0.0. requires PhyloPlots v1.0.0\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#index","page":"public","title":"index","text":"","category":"section"},{"location":"lib/public/","page":"public","title":"public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"#PhyloTraits","page":"Home","title":"PhyloTraits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PhyloTraits is a Julia package with core utilities for phylogenetic networks. See the PhyloNetworks package, which PhyloTraits depends on, for background on phylogenetic networks and for how to get help.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See them in bibtex format.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quick links for methods about trait evolution on networks:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Teo, Rose, Bastide & Ané (2023). Accounting for intraspecific variation in continuous trait evolution on a reticulate phylogeny. Bulletin of the Society of Systematic Biologists, 2(3):1-29. doi: 10.18061/bssb.v2i3.8977\nKarimi, Grover, Gallagher, Wendel, Ané & Baum (2020). Reticulate evolution helps explain apparent homoplasy in floral biology and pollination in baobabs (Adansonia; Bombacoideae; Malvaceae). Systematic Biology, 69(3):462-478. doi:10.1093/sysbio/syz073.\nBastide, Solís-Lemus, Kriebel, Sparks, Ané (2018). Phylogenetic Comparative Methods for Phylogenetic Networks with Reticulations. Systematic Biology, 67(5):800–820. doi:10.1093/sysbio/syy033.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The manual pages contain detailed tutorials on how to use the functions of the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/phyloregression.md\",\n    \"man/simulate_continuous.md\",\n    \"man/fitDiscrete.md\",\n    \"man/fitdiscreteDNA.md\",\n    \"man/simulate_discrete.md\",\n]\nDepth = 3","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section contains example of empirical analyses from the literature.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/example_fishes.md\",\n]\nDepth = 3","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For help on individual functions, see this library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/public.md\",\n    \"lib/internal.md\",\n]\nDepth = 3","category":"page"},{"location":"lib/internal/#internal-documentation","page":"internals","title":"internal documentation","text":"","category":"section"},{"location":"lib/internal/","page":"internals","title":"internals","text":"Documentation for PhyloTraits's internal functions. These functions are not exported and their access (API) should not be considered stable. But they can still be used, like this for example: PhyloTraits.foo() for a function named foo().","category":"page"},{"location":"lib/internal/#functions-and-types","page":"internals","title":"functions & types","text":"","category":"section"},{"location":"lib/internal/#PhyloTraits.BM","page":"internals","title":"PhyloTraits.BM","text":"BM(λ)\n\nBrownian Motion, subtype of ContinuousTraitEM, to model the population mean of a trait (or of the residuals from a linear model). Under the BM model, the population (or species) means have a multivariate normal distribution with covariance matrix = σ²λV, where σ² is the between-species variance-rate (to be estimated), and the matrix V is obtained from PhyloNetworks.sharedpathmatrix(net)[:tips].\n\nλ is set to 1 by default, and is immutable. In future versions, λ may be used to control the scale for σ².\n\nOn a tree, V is the length of shared ancestry. On a network, the BM model assumes that the trait at a hybrid node is the weighted average of its immediate parents (plus possibly a fixed shift). The weights are the proportion of genes inherited from each parent: the γ parameters of hybrid edges.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PhyloTraits.ContinuousTraitEM","page":"internals","title":"PhyloTraits.ContinuousTraitEM","text":"ContinuousTraitEM\n\nAbstract type for evolutionary models for continuous traits, using a continuous-time stochastic process on a phylogeny.\n\nFor subtypes, see BM, PagelLambda, ScalingHybrid.\n\nEach of these subtypes/models has the field lambda, whose default value is 1.0. However, the interpretation of this field differs across models.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PhyloTraits.NucleicAcidSubstitutionModel","page":"internals","title":"PhyloTraits.NucleicAcidSubstitutionModel","text":"NucleicAcidSubstitutionModel\n\nAdapted from SubstitutionModels.jl in BioJulia. The same Q and P function names are used for the transition rates and probabilities.\n\nFor subtypes, see JC69, HKY85\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PhyloTraits.OptSummary","page":"internals","title":"PhyloTraits.OptSummary","text":"OptSummary{T<:AbstractFloat}\n\nSummary of an NLopt optimization. Idea and code taken from MixedModels. T is the type of the function argument(s) and of the function value.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PhyloTraits.PagelLambda","page":"internals","title":"PhyloTraits.PagelLambda","text":"PagelLambda(λ)\n\nPagel's λ model, subtype of ContinuousTraitEM, with covariance matrix σ²V(λ). σ² is the between-species variance-rate (to be estimated), and V(λ) = λV + (1-λ)T, where V is the covariance under a Brownian motion BM and T is a diagonal matrix containing the total branch length elapsed from the root to each leaf (if the phylogeny is a tree, or more generally if the network is time consistent: the time from the root to a given node does not depend on the path).\n\nλ ∈ [0,1] is mutable and may be optimized. It is a measure of phylogenetic signal, that is, how important the given network is for explaining variation in the response. When λ=1, the PagelLambda model reduces to the BM model.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PhyloTraits.ScalingHybrid","page":"internals","title":"PhyloTraits.ScalingHybrid","text":"ScalingHybrid(λ)\n\nScaling Hybrid model, subtype of ContinuousTraitEM, with covariance matrix σ²V(N(λ)). σ² is the between-species variance-rate (to be estimated), V(N) is the Brownian motion BM covariance obtained from network N, and N(λ) is a obtained from the input network by rescaling the inheritance parameter γ of all minor edges by the same λ: a minor edge has its original γ changed to λγ, using the same λ at all reticulations. Note that for a major edge with original inheritance γ, the partner minor edge has inheritance γminor = 1-γ, so the major edge's inheritance is changed to 1-λγminor = λγ+1-λ. Warning: this model assumes that all hybrid nodes are bicombining, that is, they have exactly 2 parents each.\n\nFor more information: see Bastide (2017) dissertation, section 4.3.2 p.175, available at here.\n\nλ ∈ [0,λmax] is mutable and may be optimized. It is a measure of how important the reticulations are for explaining variation in the response.\n\nWhen λ = 1, the ScalingHybrid model reduces to the BM model on the original network N.\nλ = 0 corresponds to the BM model on N's major tree (after removing all minor hybrid edges). Please note that testing the null hypothesis \"λ = 0\" would require comparing the likelihood ratio statistic to a null distribution that is not a chi-square distribution with 1 degree freedom, because 0 is at the boundary of allowable λ values. A mixture of 2 chi-square distributions might be appropriate (see for example Mitchell, Allman & Rhodes 2019 and references therein).\nλmax = 1/maximum(γminor) ≥ 1. It is the maximum λ value such that λγminor ≤ 1 at all hybrid nodes.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PhyloTraits.StatisticalSubstitutionModel","page":"internals","title":"PhyloTraits.StatisticalSubstitutionModel","text":"StatisticalSubstitutionModel(\n    model::SubstitutionModel,\n    ratemodel::RateVariationAcrossSites,\n    net::HybridNetwork,\n    trait::AbstractVector,\n    siteweight::Union{Nothing, Vector{Float64}}=nothing,\n    maxhybrid::Int=length(net.hybrid)\n)\n\nInner constructor. Makes a deep copy of the input model, rate model. Warning: does not make a deep copy of the network: modification of the object.net would modify the input net. Assumes that the network has valid gamma values (to extract displayed trees).\n\nStatisticalSubstitutionModel(\n    net::HybridNetwork,\n    fastafile::String,\n    modsymbol::Symbol,\n    rvsymbol::Symbol=:noRV,\n    ratecategories::Int=4;\n    maxhybrid::Int=length(net.hybrid)\n)\n\nConstructor from a network and a fasta file. The model symbol should be one of :JC69, :HKY85, :ERSM or :BTSM. The rvsymbol should be as required by RateVariationAcrossSites.\n\nThe network's gamma values are modified if they are missing. After that, a deep copy of the network is passed to the inner constructor.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PhyloTraits.StatisticalSubstitutionModel-2","page":"internals","title":"PhyloTraits.StatisticalSubstitutionModel","text":"StatisticalSubstitutionModel\n\nSubtype of StatsBase.StatisticalModel, to fit discrete data to a model of trait substitution along a network. See fitdiscrete to fit a trait substitution model to discrete data. It returns an object of type StatisticalSubstitutionModel, to which standard functions can be applied, like loglikelihood(object), aic(object) etc.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PhyloTraits.SubstitutionModel","page":"internals","title":"PhyloTraits.SubstitutionModel","text":"SubstitutionModel\n\nAbstract type for substitution models, using a continous time Markov model on a phylogeny. Adapted from SubstitutionModels.jl in BioJulia.\n\nFor variable rates, see RateVariationAcrossSites\n\nFor sub types, see NucleicAcidSubstitutionModel, TraitSubstitutionModel\n\nAll these models are supposed to have fields rate and eigeninfo.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PhyloTraits.WithinSpeciesCTM","page":"internals","title":"PhyloTraits.WithinSpeciesCTM","text":"WithinSpeciesCTM\n\nType to fit models accounting for within-species variation, including measurement error, genetic variation between individuals, plasticity, environmental variation etc. CTM stands for \"continuous trait model\". Contains the estimated variance components (between-species phylogenetic variance rate and within-species variance) and output from the NLopt optimization used in the estimation.\n\nfields\n\nwsp_var: intra/within-species variance.\nbsp_var: inter/between-species variance-rate.\nwsp_ninv: vector of the inverse sample-sizes (e.g. [1/n₁, ..., 1/nₖ], where data from k species was used to fit the model and nᵢ is the no. of observations for the ith species).\nrss: within-species sum of squares\noptsum: an OptSummary object.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#Base.getindex","page":"internals","title":"Base.getindex","text":"getindex(obj::TraitSimulation, d::Symbol, w::Symbol)\n\nGetting submatrices of an object of type TraitSimulation.\n\nArguments\n\nobj::TraitSimulation: the matrix from which to extract.\nd: symbol specifying which sub-matrix to extract. Can be:\n:tips columns and/or rows corresponding to the tips\n:internalnodes columns and/or rows corresponding to the internal nodes\nw: symbol specifying whether simulated (:sim) or mean expected (:exp) values are desired.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PhyloTraits.P!-Tuple{AbstractMatrix, PhyloTraits.SubstitutionModel, Float64}","page":"internals","title":"PhyloTraits.P!","text":"P!(Pmat::AbstractMatrix, obj::SM, t::Float64)\n\nFill in the input matrix Pmat with the transition rates to go from each state to another in time t, according to rates in Q. see also: P.\n\njulia> m1 = BinaryTraitSubstitutionModel([1.0,2.0], [\"low\",\"high\"])\nBinary Trait Substitution Model:\nrate low→high α=1.0\nrate high→low β=2.0\n\njulia> PhyloTraits.P!(Matrix{Float64}(undef,2,2), m1, 0.3) # fills an uninitialized 2x2 matrix of floats\n2×2 Matrix{Float64}:\n 0.80219  0.19781\n 0.39562  0.60438\n\njulia> m2 = JC69([1.]);\n\njulia> PhyloTraits.P!(Matrix{Float64}(undef,4,4), m2, 0.2)\n4×4 Matrix{Float64}:\n 0.824446   0.0585179  0.0585179  0.0585179\n 0.0585179  0.824446   0.0585179  0.0585179\n 0.0585179  0.0585179  0.824446   0.0585179\n 0.0585179  0.0585179  0.0585179  0.824446 \n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.P-Tuple{PhyloTraits.SubstitutionModel, Float64}","page":"internals","title":"PhyloTraits.P","text":"P(obj, t)\n\nProbability transition matrix for a SubstitutionModel, of the form\n\nP[1,1] ... P[1,k]\n   .          .\n   .          .\nP[k,1] ... P[k,k]\n\nwhere P[i,j] is the probability of ending in state j after time t, given that the process started in state i. see also: P!.\n\nHKY example:\n\njulia> m1 = HKY85([0.5], [0.20, 0.30, 0.30, 0.20])\nHKY85 Substitution Model base frequencies: [0.2, 0.3, 0.3, 0.2]\nrelative rate version with transition/tranversion ratio kappa = 0.5,\n scaled so that there is one substitution per unit time\nrate matrix Q:\n               A       C       G       T\n       A       *  0.4839  0.2419  0.3226\n       C  0.3226       *  0.4839  0.1613\n       G  0.1613  0.4839       *  0.3226\n       T  0.3226  0.2419  0.4839       *\n\njulia> PhyloTraits.P(m1, 0.2)\n4×4 StaticArraysCore.MMatrix{4, 4, Float64, 16} with indices SOneTo(4)×SOneTo(4):\n 0.81592    0.0827167  0.0462192  0.0551445\n 0.0551445  0.831326   0.0827167  0.0308128\n 0.0308128  0.0827167  0.831326   0.0551445\n 0.0551445  0.0462192  0.0827167  0.81592  \n\nJuke-Cantor example:\n\njulia> m1 = JC69([1.]);\n\njulia> PhyloTraits.P(m1, 0.2)\n4×4 StaticArraysCore.MMatrix{4, 4, Float64, 16} with indices SOneTo(4)×SOneTo(4):\n 0.824446   0.0585179  0.0585179  0.0585179\n 0.0585179  0.824446   0.0585179  0.0585179\n 0.0585179  0.0585179  0.824446   0.0585179\n 0.0585179  0.0585179  0.0585179  0.824446 \n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.anova-Tuple{Vararg{PhyloNetworkLinearModel}}","page":"internals","title":"PhyloTraits.anova","text":"anova(objs::PhyloNetworkLinearModel...)\n\nTakes several nested fits of the same data, and computes the F statistic for each pair of models.\n\nThe fits must be results of function phylolm called on the same data, for models that have more and more effects.\n\nReturns a DataFrame object with the anova table.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.check_matchtaxonnames!-Tuple{AbstractVector, AbstractVector, PhyloNetworks.HybridNetwork}","page":"internals","title":"PhyloTraits.check_matchtaxonnames!","text":"check_matchtaxonnames!(species, data, net; kwargs...)\n\nModify species and dat by removing the species (rows) absent from the network. Return a new network (net is not modified) with tips matching those in species: if some species in net have no data, these species are pruned from the network. The network also has its node names reset, such that leaves have nodes have consecutive numbers starting at 1, with leaves first.\n\nThe optional keyword argument suppresswarnings, which is false by default, can be set to true to suppress warnings about taxa in the network without data.\n\nUsed by fitdiscrete to build a new StatisticalSubstitutionModel.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.defaultsubstitutionmodel","page":"internals","title":"PhyloTraits.defaultsubstitutionmodel","text":"defaultsubstitutionmodel(network, modsymbol::Symbol, data::DataFrame,\n              siteweights::Vector)\n\nReturn a statistical substitution model (SSM) with appropriate state labels and a rate appropriate for the branch lengths in net (see startingrate). The data frame must have the actual trait/site data in columns 2 and up, as when the species names are in column 1. For DNA data, the relative rate model is returned, with a stationary distribution equal to the empirical frequencies.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PhyloTraits.discrete_backwardlikelihood_trait!-Tuple{PhyloTraits.StatisticalSubstitutionModel, Integer, Integer}","page":"internals","title":"PhyloTraits.discrete_backwardlikelihood_trait!","text":"discrete_backwardlikelihood_trait!(obj::SSM, tree::Integer, ri::Integer)\n\nUpdate and return the backward likelihood (last argument backwardlik) assuming rate category ri and tree index tree, using current forward and backwards likelihoods in obj: these depend on the trait (or site) given to the last call to discrete_corelikelihood_trait!. Used by ancestralreconstruction.\n\nwarning: assume correct transition probabilities.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.discrete_corelikelihood!-Tuple{PhyloTraits.StatisticalSubstitutionModel}","page":"internals","title":"PhyloTraits.discrete_corelikelihood!","text":"discrete_corelikelihood!(obj::StatisticalSubstitutionModel;\n                         whichtrait::AbstractVector{Int} = 1:obj.nsites)\n\nCalculate the likelihood and update obj.loglik for discrete characters on a network, calling discrete_corelikelihood_trait!. The algorithm extracts all displayed trees and weighs the likelihood under all these trees. The object's partial likelihoods are updated:\n\nforward and direct partial likelihoods are re-used, one trait at a time,\noverall likelihoods on each displayed tree, given each rate category and for each given site/trait: are cached in _loglikcache.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.discrete_corelikelihood_trait!-Tuple{PhyloTraits.StatisticalSubstitutionModel, Integer, Integer, Integer}","page":"internals","title":"PhyloTraits.discrete_corelikelihood_trait!","text":"discrete_corelikelihood_trait!(obj::SSM, t::Integer, ci::Integer, ri::Integer)\n\nReturn the likelihood for tree t, trait (character/site) index ci and rate category ri. Update & modify the forward & directional log-likelihoods obj.forwardlik and obj.directlik, which are indexed by [state, nodenumber or edgenumber]. Used by discrete_corelikelihood!.\n\nPreconditions: obj.logtrans updated, edges directed, nodes/edges preordered\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.formatinterval","page":"internals","title":"PhyloTraits.formatinterval","text":"formatinterval(obj::ReconstructedStates, pred::DataFrame, withexpectation::Bool=false, digits::Int=2)\n\nFormat the prediction intervals for the plotting function. If withexpectation is set to true, then the best predicted value is also shown along with the interval.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PhyloTraits.getGammas-Tuple{PhyloNetworks.HybridNetwork}","page":"internals","title":"PhyloTraits.getGammas","text":"getGammas(net)\n\nVector of inheritance γ's of all major edges (tree edges and major hybrid edges), ordered according to the pre-order index of their child node, assuming this pre-order is already calculated (with up-to-date field vec_node). Here, a \"major\" edge is an edge with field ismajor set to true, regardless of its actual γ (below, at or above 0.5).\n\nSee setGammas!\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.getmissingtipmarks","page":"internals","title":"PhyloTraits.getmissingtipmarks","text":"getmissingtipmarks(obj::ReconstructedStates, missingmark::AbstractString=\"*\")\n\nCreate a vector of string, with a missingmark for tips that are missing.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PhyloTraits.getparameters-Tuple{PhyloTraits.RVASInv}","page":"internals","title":"PhyloTraits.getparameters","text":"getparameters(obj::RateVariationAcrossSites)\n\nReturn a copy of the alpha and/or pinv parameters of model obj, in a single vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.getparamindex-Tuple{PhyloTraits.RVASInv}","page":"internals","title":"PhyloTraits.getparamindex","text":"getparamindex(obj::RateVariationAcrossSites)\n\nIndices of parameters in (p_invariable, alpha).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.getpredint-Tuple{ReconstructedStates}","page":"internals","title":"PhyloTraits.getpredint","text":"getpredint(obj::ReconstructedStates; level::Real=0.95)\n\nPrediction intervals with level level for internal nodes and missing tips.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.lambda!-Tuple{PhyloNetworkLinearModel, Any}","page":"internals","title":"PhyloTraits.lambda!","text":"lambda!(m::PhyloNetworkLinearModel, newlambda)\nlambda!(m::ContinuousTraitEM, newlambda)\n\nAssign a new value to the lambda parameter.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.lambda-Tuple{PhyloNetworkLinearModel}","page":"internals","title":"PhyloTraits.lambda","text":"lambda(m::PhyloNetworkLinearModel)\nlambda(m::ContinuousTraitEM)\n\nValue assigned to the lambda parameter, if appropriate.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.learnlabels-Tuple{Symbol, DataFrames.AbstractDataFrame}","page":"internals","title":"PhyloTraits.learnlabels","text":"learnlabels(model::Symbol, dat::DataFrame)\n\nReturn unique non-missing values in dat, and check that these labels can be used to construct of substitution model of type model.\n\nexamples:\n\njulia> using DataFrames\n\njulia> dat = DataFrame(trait1 = [\"A\", \"C\", \"A\", missing]); # 4×1 DataFrame\n\njulia> PhyloTraits.learnlabels(:BTSM, dat)\n2-element Vector{String}:\n \"A\"\n \"C\"\n\njulia> PhyloTraits.learnlabels(:JC69, dat)\n2-element Vector{String}:\n \"A\"\n \"C\"\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.posterior_loghybridweight","page":"internals","title":"PhyloTraits.posterior_loghybridweight","text":"posterior_loghybridweight(obj::SSM, hybrid_name, trait = 1)\nposterior_loghybridweight(obj::SSM, edge_number, trait = 1)\n\nLog-posterior probability for all trees displaying the minor parent edge of hybrid node named hybrid_name, or displaying the edge number edge_number. That is: log of P(hybrid minor parent | trait) if a single trait is requested, or A[i]= log of P(hybrid minor parent | trait i) if trait is a vector or range (e.g. trait = 1:obj.nsites). These probabilities are conditional on the model parameters in obj.\n\nPrecondition: _loglikcache updated by discrete_corelikelihood!\n\nexamples\n\njulia> net = readnewick(\"(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [\"lo\", \"hi\"]); # arbitrary rates\n\njulia> using DataFrames\n\njulia> dat = DataFrame(species=[\"C\",\"A\",\"B\",\"D\"], trait=[\"hi\",\"lo\",\"lo\",\"hi\"]);\n\njulia> fit = fitdiscrete(net, m1, dat); # optimized rates: α=0.27 and β=0.35\n\njulia> plhw = PhyloTraits.posterior_loghybridweight(fit, \"H1\");\n\njulia> round(exp(plhw), digits=5) # posterior probability of going through minor hybrid edge\n0.08017\n\njulia> hn = net.node[3]; getparentedgeminor(hn).gamma # prior probability\n0.1\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PhyloTraits.posterior_logtreeweight","page":"internals","title":"PhyloTraits.posterior_logtreeweight","text":"posterior_logtreeweight(obj::SSM, trait = 1)\n\nArray A of log-posterior probabilities for each tree displayed in the network: such that A[t] = log of P(tree t | trait trait) if a single trait is requested, or A[t,i]= log of P(tree t | trait i) if trait is a vector or range (e.g. trait = 1:obj.nsites). These probabilities are conditional on the model parameters in obj.\n\nDisplayed trees are listed in the order in which they are stored in the fitted model object obj.\n\nPrecondition: _loglikcache updated by discrete_corelikelihood!\n\nexamples\n\njulia> net = readnewick(\"(((A:2.0,(B:1.0)#H1:0.1::0.9):1.5,(C:0.6,#H1:1.0::0.1):1.0):0.5,D:2.0);\");\n\njulia> m1 = BinaryTraitSubstitutionModel([0.1, 0.1], [\"lo\", \"hi\"]); # arbitrary rates\n\njulia> using DataFrames\n\njulia> dat = DataFrame(species=[\"C\",\"A\",\"B\",\"D\"], trait=[\"hi\",\"lo\",\"lo\",\"hi\"]);\n\njulia> fit = fitdiscrete(net, m1, dat); # optimized rates: α=0.27 and β=0.35\n\njulia> pltw = PhyloTraits.posterior_logtreeweight(fit);\n\njulia> round.(exp.(pltw), digits=5) # posterior trees probabilities (sum up to 1)\n2-element Vector{Float64}:\n 0.91983\n 0.08017\n\njulia> round.(exp.(fit.priorltw), digits=4) # the prior tree probabilities are similar here (tiny data set!)\n2-element Vector{Float64}:\n 0.9\n 0.1\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PhyloTraits.setGammas!-Tuple{PhyloNetworks.HybridNetwork, Vector}","page":"internals","title":"PhyloTraits.setGammas!","text":"setGammas!(net, γ vector)\n\nSet inheritance γ's of hybrid edges, using input vector for major edges. Assume pre-order calculated already, with up-to-date field vec_node. See getGammas.\n\nWarning: very different from PhyloNetworks.setgamma!, which focuses on a single hybrid event, updates the field ismajor according to the new γ, and is not used here.\n\nAssumption: each hybrid node has only 2 parents, a major and a minor parent (according to the edges' field ismajor).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.setalpha!-Union{Tuple{S}, Tuple{PhyloTraits.RVASGamma{S}, Float64}} where S","page":"internals","title":"PhyloTraits.setalpha!","text":"setalpha!(obj, alpha)\n\nSet the shape parameter alpha in a RateVariationAcrossSites model obj, and update the rate multipliers accordingly. Return the modified object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.seteigeninfo!-Tuple{BinaryTraitSubstitutionModel}","page":"internals","title":"PhyloTraits.seteigeninfo!","text":"for a [BinaryTraitSubstitutionModel]: store eigenvalue (q01+q10) and stationary distribution\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.seteigeninfo!-Tuple{EqualRatesSubstitutionModel}","page":"internals","title":"PhyloTraits.seteigeninfo!","text":"for a [EqualRatesSubstitutionModel]: store lambda = k/(k-1), where k is the number of states\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.seteigeninfo!-Tuple{HKY85}","page":"internals","title":"PhyloTraits.seteigeninfo!","text":"for HKY85: store piR, piY, the 2 non-zero eigenvalues and a scaling factor\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.seteigeninfo!-Tuple{JC69}","page":"internals","title":"PhyloTraits.seteigeninfo!","text":"for JC69: store lambda = 4/3 (if relative) or rate * 4/3 (absolute).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.seteigeninfo!-Tuple{PhyloTraits.SubstitutionModel}","page":"internals","title":"PhyloTraits.seteigeninfo!","text":"seteigeninfo!(obj)\n\nCalculate eigenvalue & eigenfector information for a substitution model (SM) object (as needed to calculate transition rate matrices) and store this info within the object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.setparameters!-Tuple{PhyloTraits.RVASInv, AbstractVector}","page":"internals","title":"PhyloTraits.setparameters!","text":"setparameters!(obj::RateVariationAcrossSites, par::AbstractVector)\n\nSet the values of the alpha and/or pinv parameters of model obj. See also setalpha!, setpinv! and setpinvalpha!\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.setpinv!-Tuple{PhyloTraits.RVASInv, Float64}","page":"internals","title":"PhyloTraits.setpinv!","text":"setpinv!(obj, pinv)\n\nSet the proportion of invariable sites pinv in a RateVariationAcrossSites model obj, and update the rate multipliers & weights accordingly. For RVASInvGamma objects, the original rate multipliers are assumed correct, according to the original pinv value. Return the modified object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.setpinvalpha!-Union{Tuple{S}, Tuple{PhyloTraits.RVASGammaInv{S}, Float64, Float64}} where S","page":"internals","title":"PhyloTraits.setpinvalpha!","text":"setpinvalpha!(obj, pinv, alpha)\n\nSet the proportion of invariable sites pinv and the alpha parameter for the discretized gamma distribution in a model obj of type RVASGammaInv{S}. Update the rate multipliers & weights accordingly. The mean of the distribution is constrained to 1.\n\nReturn the modified object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.setrates!-Tuple{PhyloTraits.SubstitutionModel, AbstractVector}","page":"internals","title":"PhyloTraits.setrates!","text":"setrates!(model, rates)\n\nupdate rates then call seteigeninfo! to update a model's eigeninfo\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.showQ-Tuple{IO, PhyloTraits.SubstitutionModel}","page":"internals","title":"PhyloTraits.showQ","text":"showQ(IO, model)\n\nPrint the Q matrix to the screen, with trait states as labels on rows and columns. adapted from prettyprint function by mcreel, found 2017/10 at https://discourse.julialang.org/t/display-of-arrays-with-row-and-column-names/1961/6\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.showdata","page":"internals","title":"PhyloTraits.showdata","text":"showdata(io::IO, obj::SSM, fullsiteinfo::Bool=false)\n\nReturn information about the data in an SSM object: number of species, number or traits or sites, number of distinct patterns, and more information if fullsiteinfo is true: number sites with missing data only, number of invariant sites, number of sites with 2 distinct states, number of parsimony-informative sites (with 2+ states being observed in 2+ tips), number of sites with some missing data, and overall proportion of entries with missing data.\n\nNote: Missing is not considered an additional state. For example, if a site contains some missing data, but all non-missing values take the same state, then this site is counted in the category \"invariant\".\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PhyloTraits.startingrate-Tuple{PhyloNetworks.HybridNetwork}","page":"internals","title":"PhyloTraits.startingrate","text":"startingrate(net)\n\nEstimate an evolutionary rate appropriate for the branch lengths in the network, which should be a good starting value before optimization in fitdiscrete, assuming approximately 1 change across the entire tree. If all edge lengths are missing, set starting rate to 1/(number of taxa).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.traitlabels2indices-Tuple{AbstractVector, PhyloTraits.SubstitutionModel}","page":"internals","title":"PhyloTraits.traitlabels2indices","text":"traitlabels2indices(data, model::SubstitutionModel)\n\nCheck that the character states in data are compatible with (i.e. subset of) the trait labels in model. All columns are used. data can be a DataFrame or a Matrix (multiple traits), or a Vector (one trait). Return a vector of vectors (one per species) with integer entries, where each state (label) is replaced by its index in model. For DNA data, any ambiguous site is treated as missing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.update_logtrans-Tuple{PhyloTraits.StatisticalSubstitutionModel, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"internals","title":"PhyloTraits.update_logtrans","text":"update_logtrans(obj::SSM, edge::Edge)\n\nUpdate the log-transition probabilities associates to one particular edge in the network.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloTraits.update_logtrans-Tuple{PhyloTraits.StatisticalSubstitutionModel}","page":"internals","title":"PhyloTraits.update_logtrans","text":"update_logtrans(obj::SSM)\n\nInitialize and update obj.logtrans, the log transition probabilities along each edge in the full network. They are re-used for each displayed tree, which is why edges are not fused around degree-2 nodes when extracting displayed trees.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsAPI.coeftable-Tuple{PhyloNetworkLinearModel}","page":"internals","title":"StatsAPI.coeftable","text":"coeftable(m::PhyloNetworkLinearModel; level::Real=0.95)\n\nReturn coefficient estimates, standard errors, t-values, p-values, and t-intervals as a StatsBase.CoefTable.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsAPI.confint-Tuple{PhyloNetworkLinearModel}","page":"internals","title":"StatsAPI.confint","text":"confint(m::PhyloNetworkLinearModel; level::Real=0.95)\n\nReturn confidence intervals for coefficients, with confidence level level, based on the t-distribution whose degree of freedom is determined by the number of species (as returned by dof_residual)\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsAPI.deviance","page":"internals","title":"StatsAPI.deviance","text":"StatsBase.deviance(m::PhyloNetworkLinearModel)\n\n-2 loglikelihood of the fitted model. See also  loglikelihood.\n\nNote: this is not the residual-sum-of-squares deviance as output by GLM, such as one would get with deviance(m.model).\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#StatsAPI.deviance-Tuple{PhyloNetworkLinearModel, Val{true}}","page":"internals","title":"StatsAPI.deviance","text":"StatsBase.deviance(m::PhyloNetworkLinearModel, Val(true))\n\nResidual sum of squares with metric V, the estimated phylogenetic covariance, if the model is appropriate.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsAPI.fit-Tuple{Type{PhyloTraits.StatisticalSubstitutionModel}, PhyloNetworks.HybridNetwork, PhyloTraits.SubstitutionModel, RateVariationAcrossSites, AbstractVector}","page":"internals","title":"StatsAPI.fit","text":"fit(StatisticalSubstitutionModel, net, model, traits; kwargs...)\nfit!(StatisticalSubstitutionModel; kwargs...)\n\nInternal function called by fitdiscrete: with same key word arguments kwargs. But dangerous: traits should be a vector of vectors as for fitdiscrete but here traits need to contain the indices of trait values corresponding to the indices in getlabels(model), and species should appear in traits in the order corresponding to the node numbers in net. See traitlabels2indices to convert trait labels to trait indices.\n\nWarning: does not perform checks. fitdiscrete calls this function after doing checks, preordering nodes in the network, making sure nodes have consecutive numbers, species are matched between data and network etc.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsAPI.loglikelihood-Tuple{PhyloNetworkLinearModel}","page":"internals","title":"StatsAPI.loglikelihood","text":"loglikelihood(m::PhyloNetworkLinearModel)\n\nLog likelihood or log restricted likelihood (REML) depending on m.reml, of the fitted model.\n\nFor models with no within-species variation, the likelihood (or REML) is calculated based on the joint density for species-level mean responses.\n\nFor within-species variation models, the likelihood is calculated based on the joint density for individual-level responses. This can be calculated from individual-level data, but also by providing species-level means and standard deviations which is accepted by phylolm.\n\nWarning: many summaries are based on the species-level model, like \"dof_residual\", \"residuals\", \"predict\" or \"deviance\". So deviance is innapropriate to compare models with within-species variation. Use loglikelihood to compare models based on data at the individual level.\n\nReminder: do not compare ML or REML values across models fit on different data. Do not compare REML values across models that do not have the same predictors (fixed effects): use ML instead, for that purpose.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsAPI.nobs-Tuple{PhyloNetworkLinearModel}","page":"internals","title":"StatsAPI.nobs","text":"StatsBase.nobs(m::PhyloNetworkLinearModel)\n\nNumber of observations: number of species with data, if the model assumes known species means, and number of individuals with data, if the model accounts for within-species variation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsAPI.nulldeviance-Tuple{PhyloNetworkLinearModel}","page":"internals","title":"StatsAPI.nulldeviance","text":"StatsBase.nulldeviance(m::PhyloNetworkLinearModel)\n\nFor appropriate phylogenetic linear models, the deviance of the null model  is the total sum of square with respect to the metric V, the estimated phylogenetic covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsAPI.predict-Tuple{ReconstructedStates}","page":"internals","title":"StatsAPI.predict","text":"predict(\n    obj::ReconstructedStates;\n    interval::Union{Symbol,Nothing}=nothing,\n    level::Real=0.95,\n    text::Bool=false,\n    digits::Int=2,\n    missingmark::AbstractString=\"*\",\n    combine::Bool=false\n)\n\nEstimated reconstructed states and, if interval=:prediction, prediction intervals with level level at all internal nodes and tips with missing traits.\n\nIf text=true, the prediction and intervals are formated as string for easy plotting with the nodelabel argument to plot from package PhyloPlots. In that case, digits controls the number of digits shown, missingmark adds a distinctive mark to the prediction of tips with missing data, (set to missingmark=\"\" for no mark), and if combine=true, the prediction and bound of the intervals are combined into a single text string.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsAPI.stderror-Tuple{PhyloNetworkLinearModel}","page":"internals","title":"StatsAPI.stderror","text":"stderror(m::PhyloNetworkLinearModel)\n\nReturn the standard errors of the coefficient estimates. See vcov for related information on how these are computed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsAPI.vcov-Tuple{PhyloNetworkLinearModel}","page":"internals","title":"StatsAPI.vcov","text":"vcov(m::PhyloNetworkLinearModel)\n\nReturn the variance-covariance matrix of the coefficient estimates.\n\nFor the continuous trait evolutionary models currently implemented, species-level mean response (conditional on the predictors), Y|X is modeled as:\n\nY|X ∼ 𝒩(Xβ, σ²ₛV) for models assuming known species mean values (no within-species variation)\nY|X ∼ 𝒩(Xβ, σ²ₛV + σ²ₑD⁻¹) for models with information from multiple individuals and assuming within-species variation\n\nThe matrix V is inferred from the phylogeny, but may also depend on additional parameters to be estimated (e.g. lambda for Pagel's Lambda model). See ContinuousTraitEM, PhyloNetworkLinearModel for more details.\n\nIf (1), then return σ²ₛ(X'V⁻¹X)⁻¹, where σ²ₛ is estimated with REML, even if the model was fitted with reml=false. This follows the conventions of nlme::gls and stats::glm in R.\n\nIf (2), then return σ²ₛ(X'W⁻¹X)⁻¹, where W = V+(σ²ₑ/σ²ₛ)D⁻¹ is estimated, and σ²ₛ & σₑ are the estimates obtained with ML or REML, depending on the reml option used to fit the model m. This follows the convention of MixedModels.fit in Julia.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#StatsModels.isnested-Tuple{PhyloNetworkLinearModel, PhyloNetworkLinearModel}","page":"internals","title":"StatsModels.isnested","text":"isnested(m1::PhyloNetworkLinearModel, m2::PhyloNetworkLinearModel)\nisnested(m1::ContinuousTraitEM, m2::ContinuousTraitEM)\n\nTrue if m1 is nested in m2, false otherwise. Models fitted with different criteria (ML and REML) are not nested. Models with different predictors (fixed effects) must be fitted with ML to be considered nested.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#index","page":"internals","title":"index","text":"","category":"section"},{"location":"lib/internal/","page":"internals","title":"internals","text":"Pages = [\"internal.md\"]","category":"page"},{"location":"man/simulate_continuous/#Continuous-trait-simulation","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"","category":"section"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"We show here how PhyloPlots can be used to simulate data under a Brownian motion (BM) process. We use the same network as in the previous section. The data used in the previous section was actually obtained using this simulation (followed by some rounding).","category":"page"},{"location":"man/simulate_continuous/#Brownian-motion","page":"Continuous trait simulation","title":"Brownian motion","text":"","category":"section"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"We simulate three traits on the network: two independent traits that serve as predictors, and one \"dependent\" trait that is affected by the first 2. We start by choosing the parameters of the BM (ancestral mean and variance), by creating objects of class ParamsBM<:ParamsProcess.","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"params_trait1 = ParamsBM( 2, 0.5) # BM with mean  2 and variance 0.5\nparams_trait2 = ParamsBM(-2, 1)   # BM with mean -2 and variance 1.0\nnothing # hide","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"We then simulate the traits to serve as predictors according to these parameters, using function rand. For reproducibility, we use a stable random number generator (RNG), but the default random generator is better (and more efficient). To use the default RNG, simply remove rng in the code below.","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"using StableRNGs; rng = StableRNG(18480224); # stable RNG for reproducibility\nsim1 = rand(rng, truenet, params_trait1)  # simulate a BM on truenet\nsim2 = rand(rng, truenet, params_trait2)\nnothing # hide","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"This creates objects of class TraitSimulation, from which we can extract the data at the tips, thanks to the method getindex(::TraitSimulation, ::Symbol).","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"trait1 = sim1[:tips] # trait 1 at the tips (data)\ntrait2 = sim2[:tips]","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"This extractor creates an Array with one column, and as many lines as the number of tips there are in the phylogeny.  It is sorted in the same order as the tips of the phylogeny used to simulate it.   If needed, we could also extract the simulated values at the internal nodes in the network:","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"sim1[:internalnodes]","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"These values (rounded to 3 digits) are those used in section Ancestral state reconstruction, when we compared the ancestral state reconstruction (or \"predictions\") of trait 1 (stored in ancTrait1) to the true simulated value.","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"Finally, we generate the last trait correlated with trait 1 (but not trait 2), with phylogenetic noise.","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"noise = rand(StableRNG(18700904), truenet, ParamsBM(0, 0.1)) # phylogenetic residuals\ntrait3 = 10 .+ 2 * trait1 .+ noise[:tips] # trait to study. independent of trait2\nnothing # hide","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"For a simulation study, we would assume that we measured the three traits above, and then we would like to apply analysis methods to these data, e.g. to see how they infer the impact of traits 1 and 2 on trait 3. To do that, we may need to create a data frame containing all 3 traits, as shown below:","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"using DataFrames\ndat = DataFrame(trait1 = trait1, trait2 = trait2, trait3 = trait3,\n                tipnames = tiplabels(sim1))","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"These data were rounded to 3 digits and used in the previous section on Phylogenetic regression.","category":"page"},{"location":"man/simulate_continuous/#shifted-Brownian-motion","page":"Continuous trait simulation","title":"shifted Brownian motion","text":"","category":"section"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"In a shifted BM, the trait evolves as a BM on the network most of the time, but undergo sudden shifts on some of the branches. The positions and values of the shifts can be stored in a ShiftNet object. The position of the shifts can be given using vector of edges. To see this, let's first plot the network with its associated edges and node numbers.","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"R\"svg\"(figname(\"truenet_with_numbers.svg\"), width=8, height=4) # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(truenet, useedgelength=true, showedgenumber=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"(Image: truenet_with_numbers)","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"For identifiability reasons, shifts are only allowed on tree (not hybrid) edges. Here, a shift on either hybrid edge 9 or 7 would have the same effect as a shift on edge 6: by shifting traits of species A and B.","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"Let's say that we want to add a shift with value 5.0 on the branch directly following the hybridization event, in order to model transgressive evolution. We can see on the plot above that this branch is number 6, so we define the following object:","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"edge_afterhyb = truenet.edge[6] # the 6th edge has number 6\nshift = ShiftNet(truenet.edge[6], 5.0,  truenet)","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"Note that the edge numbers and values of a ShiftNet object can be retrieved thanks to functions getshiftedgenumber and getshiftvalue. The constructor can take a single edge and associated value, like here, or two vectors of edges and matching values.","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"Because we often need to put shifts only on edges right after hybrids, there is a special function shiftathybrids to do that, so that we do not have to find out their edges number. Here, the shift object could hence have been defined as:","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"shift = shiftathybrids(5.0,  truenet)","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"The parameters for the simulation are then defined as above, just adding our ShiftNet object as a parameter. Again, we use a custom stable random number generator to make our example reproducible, but we recommend against this random number generator forf simulation studies (just remove the argument rng).","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"params_sh = ParamsBM(2, 0.5, shift) # BM with mean 2, variance 0.5, and shifts.\nnothing # hide","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"The traits are simulated using the same function rand, and extracted at the tips as before.","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"rng = StableRNG(18700904)\nsim_sh = rand(rng, truenet, params_sh) # simulate a shifted BM on truenet\ntrait_sh = sim_sh[:tips]          # trait at the tips (data)","category":"page"},{"location":"man/simulate_continuous/","page":"Continuous trait simulation","title":"Continuous trait simulation","text":"tiplabels(sim_sh)","category":"page"}]
}
