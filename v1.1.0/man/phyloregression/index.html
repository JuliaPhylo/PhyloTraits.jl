<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Continuous trait analysis · PhyloTraits.jl</title><meta name="title" content="Continuous trait analysis · PhyloTraits.jl"/><meta property="og:title" content="Continuous trait analysis · PhyloTraits.jl"/><meta property="twitter:title" content="Continuous trait analysis · PhyloTraits.jl"/><meta name="description" content="Documentation for PhyloTraits.jl."/><meta property="og:description" content="Documentation for PhyloTraits.jl."/><meta property="twitter:description" content="Documentation for PhyloTraits.jl."/><meta property="og:url" content="https://JuliaPhylo.github.io/PhyloTraits.jl/man/phyloregression/"/><meta property="twitter:url" content="https://JuliaPhylo.github.io/PhyloTraits.jl/man/phyloregression/"/><link rel="canonical" href="https://JuliaPhylo.github.io/PhyloTraits.jl/man/phyloregression/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="PhyloTraits.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="PhyloTraits.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PhyloTraits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Continuous trait analysis</a><ul class="internal"><li><a class="tocitem" href="#Model-and-variance-matrix"><span>Model and variance matrix</span></a></li><li><a class="tocitem" href="#Phylogenetic-regression"><span>Phylogenetic regression</span></a></li><li><a class="tocitem" href="#Ancestral-state-reconstruction"><span>Ancestral state reconstruction</span></a></li><li><a class="tocitem" href="#Phylogenetic-ANOVA"><span>Phylogenetic ANOVA</span></a></li><li><a class="tocitem" href="#Pagel&#39;s-Lambda"><span>Pagel&#39;s Lambda</span></a></li><li><a class="tocitem" href="#Test-of-transgressive-evolution"><span>Test of transgressive evolution</span></a></li></ul></li><li><a class="tocitem" href="../simulate_continuous/">Continuous trait simulation</a></li><li><a class="tocitem" href="../fitDiscrete/">Discrete trait analysis</a></li><li><a class="tocitem" href="../fitdiscreteDNA/">DNA evolutionary models</a></li><li><a class="tocitem" href="../simulate_discrete/">Discrete trait simulation</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example_fishes/">Xiphophorus fishes</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">public</a></li><li><a class="tocitem" href="../../lib/internal/">internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Continuous trait analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Continuous trait analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/PhyloTraits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/PhyloTraits.jl/blob/main/docs/src/man/phyloregression.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Continuous-trait-analysis"><a class="docs-heading-anchor" href="#Continuous-trait-analysis">Continuous trait analysis</a><a id="Continuous-trait-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-trait-analysis" title="Permalink"></a></h1><p>After inferring a phylogeny, we can take these phylogenetic relationships into account when studying the distribution of quantitative traits measured for extant species. This is the goal of phylogenetic comparative methods (PCM). With PhyloTraits, we can do so for a phylogeny that is either a tree, or a network with reticulations. More details can be found on the developments below in Bastide et al. 2018 <sup class="footnote-reference"><a id="citeref-B18" href="#footnote-B18">[B18]</a></sup></p><p>We assume a fixed network (which may be a tree), correctly rooted, with branch lengths proportional to calendar time. Below, we use a network that is time-consistent (all paths from the root to any given node have the same length) and ultrametric (all the tips are contemporary).</p><pre><code class="language-julia hljs">truenet = readnewick(&quot;((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);&quot;);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PhyloNetworks.HybridNetwork, Rooted Network
13 edges
13 nodes: 6 tips, 1 hybrid nodes, 6 internal tree nodes.
tip labels: D, C, A, B, ...
((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0.0::0.3,E:3.0):6.2):2.0,O:11.2);
</code></pre><p>We can plot the network thanks to package <a href="https://github.com/juliaphylo/PhyloPlots.jl">PhyloPlots</a>, which uses <a href="https://juliainterop.github.io/RCall.jl/stable/gettingstarted/"><code>RCall</code></a>. The <code>name</code> function is only instrumental here, to ensure that the figure is saved in the correct directory when the documentation is built. We only show the commands to actually save the plot in this first example for the interested reader, but we will hide those in the rest of the chapter, for the sake of clarity.</p><pre><code class="language-julia hljs">using PhyloPlots, RCall
name(x) = joinpath(&quot;..&quot;, &quot;assets&quot;, &quot;figures&quot;, x)
R&quot;svg&quot;(name(&quot;truenet.svg&quot;), width=8, height=4)
R&quot;par&quot;(mar=[0,0,0,0])
plot(truenet, useedgelength=true, showgamma=true);
R&quot;dev.off()&quot;</code></pre><p><img src="../../assets/figures/truenet.svg" alt="truenet"/></p><h2 id="Model-and-variance-matrix"><a class="docs-heading-anchor" href="#Model-and-variance-matrix">Model and variance matrix</a><a id="Model-and-variance-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Model-and-variance-matrix" title="Permalink"></a></h2><p>Assuming that the network is known and that the continuous traits evolve under a Brownian Motion (BM) over time, it is possible to compute the expected variance covariance matrix between tip measurements. This can be done using function <a href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/public/#PhyloNetworks.vcv-Tuple%7BHybridNetwork%7D"><code>PhyloNetworks.vcv</code></a>, whose syntax is inspired from the well known corresponding <a href="https://CRAN.R-project.org/package=ape"><code>ape</code></a> function.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = vcv(truenet)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">6×6 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> D        C        A        B        E        O       </span>
     │<span class="sgr90"> Float64  Float64  Float64  Float64  Float64  Float64 </span>
─────┼──────────────────────────────────────────────────────
   1 │    11.2     10.8    4.8      4.8       2.0       0.0
   2 │    10.8     11.2    4.8      4.8       2.0       0.0
   3 │     4.8      4.8    8.596    7.796     3.86      0.0
   4 │     4.8      4.8    7.796    8.596     3.86      0.0
   5 │     2.0      2.0    3.86     3.86     11.2       0.0
   6 │     0.0      0.0    0.0      0.0       0.0      11.2</code></pre><p>The matrix is returned as a <code>DataFrame</code>, with columns named by the tips of the network to allow for easy identification. Each row also corresponds to a tip in the network, and rows are ordered in the same way as columns.</p><p>The computation of this matrix is based on the more general function <a href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/public/#PhyloNetworks.sharedpathmatrix-Tuple%7BHybridNetwork%7D"><code>PhyloNetworks.sharedpathmatrix</code></a>. It is at the core of all the Phylogenetic Comparative Methods described below.</p><h2 id="Phylogenetic-regression"><a class="docs-heading-anchor" href="#Phylogenetic-regression">Phylogenetic regression</a><a id="Phylogenetic-regression-1"></a><a class="docs-heading-anchor-permalink" href="#Phylogenetic-regression" title="Permalink"></a></h2><p>Assume that we measured three continuous traits in the data frame below. We want to study the impact of traits 1 and 2 on trait 3. To do that, we can perform a phylogenetic regression.</p><p>To make sure that data are mapped to the correct tip in the phylogeny, even though the tips might be ordered differently in the data frame compared to the phylogeny, our data needs to have a column with the names of the tips in the network. If this column is labeled <code>tipnames</code>, fitting the data will not require an extra option.</p><pre><code class="language-julia hljs">using DataFrames
dat = DataFrame(
  trait1 = [ 2.668,  3.696,  4.541, 4.846,  2.268, -0.331],
  trait2 = [-3.008, -4.146, -2.338, 0.655, -3.339, -4.566],
  trait3 = [15.424, 17.333, 18.115, 18.81, 13.337, 10.012],
  tipnames = [&quot;D&quot;, &quot;C&quot;, &quot;A&quot;, &quot;B&quot;, &quot;E&quot;, &quot;O&quot;]
)</code></pre><p>Phylogenetic regression / ANOVA is based on the <a href="https://github.com/JuliaStats/GLM.jl">GLM</a> package, with the network as an extra argument, using function <a href="../../lib/public/#PhyloTraits.phylolm"><code>phylolm</code></a>.</p><pre><code class="language-julia hljs">using StatsModels # for statistical model formulas
fitTrait3 = phylolm(@formula(trait3 ~ trait1 + trait2), dat, truenet)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PhyloNetworkLinearModel

Formula: trait3 ~ 1 + trait1 + trait2

Model: Brownian motion

Parameter Estimates, using REML:
phylogenetic variance rate: 0.0497118

Coefficients:
───────────────────────────────────────────────────────────────────────────
                   Coef.  Std. Error      t  Pr(&gt;|t|)  Lower 95%  Upper 95%
───────────────────────────────────────────────────────────────────────────
(Intercept)  10.1914       0.583065   17.48    0.0004   8.33586   12.047
trait1        1.80638      0.131992   13.69    0.0008   1.38632    2.22643
trait2        0.00938428   0.0761694   0.12    0.9097  -0.233021   0.251789
───────────────────────────────────────────────────────────────────────────
Log Likelihood: -5.2429275733
AIC: 18.4858551467
</code></pre><p>The REML criterion is used by default, for estimating the variance parameter(s). ML could be used instead with option <code>reml=false</code>.   From this, we can see that the intercept, the coefficient for trait 1 and the variance of the noise are correctly estimated (given that there are only 6 taxa). In addition, the Student T test for the coefficient associated with trait 2 has a high p-value, which means that this coefficient is not significantly different from 0. This is consistent with the way we simulated trait 3.</p><p>The function returns an object of type <a href="../../lib/public/#PhyloTraits.PhyloNetworkLinearModel"><code>PhyloNetworkLinearModel</code></a><code>&lt;:GLM.LinPredModel</code>. It is a subtype of the GLM type <code>LinPredModel</code>, which means that all base functions from Julia <a href="https://github.com/JuliaStats/StatsBase.jl">StatsBase</a> can be applied to it. See the documentation for this type for a list of all functions that can be used. Some functions allow the user to retrieve directly the estimated parameters of the BM, and are specific to this object.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sigma2_phylo(fitTrait3) # estimated variance of the BM</code><code class="nohighlight hljs ansi" style="display:block;">0.0497117953656881</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mu_phylo(fitTrait3) # estimated root value of the BM</code><code class="nohighlight hljs ansi" style="display:block;">10.191436829060924</code></pre><h2 id="Ancestral-state-reconstruction"><a class="docs-heading-anchor" href="#Ancestral-state-reconstruction">Ancestral state reconstruction</a><a id="Ancestral-state-reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#Ancestral-state-reconstruction" title="Permalink"></a></h2><h3 id="From-known-parameters"><a class="docs-heading-anchor" href="#From-known-parameters">From known parameters</a><a id="From-known-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#From-known-parameters" title="Permalink"></a></h3><p>If we assume that we know the exact model of evolution that generated the traits, we can do ancestral trait reconstruction. Here, we simulated trait 1 ourselves (see next section), so we can use the true process with the true parameters. In other words, we can reconstruct the state at the internal nodes, given the values at the tips, the known value at the root (2) and the known BM variance (0.5).</p><pre><code class="language-julia hljs">ancTrait1 = ancestralreconstruction(truenet, dat.trait1, ParamsBM(2, 0.5))</code></pre><p>Function <a href="../../lib/public/#PhyloTraits.ancestralreconstruction"><code>ancestralreconstruction</code></a> creates an object with type <a href="../../lib/public/#PhyloTraits.ReconstructedStates"><code>ReconstructedStates</code></a>. Several extractors can be applied to it:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StatsAPI, StatsBase # for predict and stderror()</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; predict(ancTrait1) # predictions</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">13×2 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> nodenumber  prediction </span>
     │<span class="sgr90"> Int64       Float64    </span>
─────┼────────────────────────
   1 │         -5     3.19235
   2 │         -7     4.52957
   3 │          5     3.62793
   4 │         -4     3.44066
   5 │         -8     2.59224
   6 │         -3     2.50005
   7 │         -2     2.0
   8 │          1     2.668
   9 │          2     3.696
  10 │          3     4.541
  11 │          4     4.846
  12 │          6     2.268
  13 │          7    -0.331</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; stderror(ancTrait1) # associated standard errors</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{Float64}:
 0.3123387589010663
 0.42993324936477556
 0.812157499454507
 0.9859957884856942
 1.0099199358487552
 0.8070424194592417
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; predict(ancTrait1, interval=:prediction, level=0.90) # prediction interval (at level 90%)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">13×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> nodenumber  prediction  lower     upper    </span>
     │<span class="sgr90"> Int64       Float64     Float64   Float64  </span>
─────┼────────────────────────────────────────────
   1 │         -5     3.19235   2.67859   3.7061
   2 │         -7     4.52957   3.82239   5.23674
   3 │          5     3.62793   2.29205   4.96381
   4 │         -4     3.44066   1.81884   5.06247
   5 │         -8     2.59224   0.93107   4.25341
   6 │         -3     2.50005   1.17258   3.82751
   7 │         -2     2.0       2.0       2.0
   8 │          1     2.668     2.668     2.668
   9 │          2     3.696     3.696     3.696
  10 │          3     4.541     4.541     4.541
  11 │          4     4.846     4.846     4.846
  12 │          6     2.268     2.268     2.268
  13 │          7    -0.331    -0.331    -0.331</code></pre><p>We can plot the ancestral states or prediction intervals on the tree, using the <code>nodelabel</code> argument of the <a href="https://juliaphylo.github.io/PhyloPlots.jl/stable/lib/public/#PhyloPlots.plot-Tuple%7BHybridNetwork%7D"><code>PhyloPlots.plot</code></a> function.</p><pre><code class="language-julia hljs">plot(truenet, nodelabel=predict(ancTrait1, text=true), tipoffset=0.1);</code></pre><p><img src="../../assets/figures/ancestral_expe.svg" alt="ancestral_expe"/></p><pre><code class="language-julia hljs">ancInt = predict(ancTrait1, interval=:prediction, text=true) # format the prediction intervals for the plot
plot(truenet, nodelabel=ancInt[!,[:nodenumber,:interval]], tipoffset=0.1);</code></pre><p><img src="../../assets/figures/ancestral_predint.svg" alt="ancestral_predint"/></p><p>The <a href="../../lib/internal/#StatsAPI.predict-Tuple{ReconstructedStates}"><code>PhyloTraits.predict</code></a> function has an optional argument to state the <code>level</code> of the prediction interval. If not given, the default value is 0.95.</p><p>It is also possible to plot both the reconstructed state and the predicted value on the same plot, using the optional keyword argument <code>combine</code>. As shown below, we could also use the <code>RCall</code> method from the <a href="https://juliaphylo.github.io/PhyloPlots.jl/stable/lib/public/#PhyloPlots.plot-Tuple%7BHybridNetwork%7D"><code>PhyloPlots.plot</code></a> function.</p><pre><code class="language-julia hljs">ancInt = predict(ancTrait1, interval=:prediction, text=true, combine=true)
plot(truenet, nodelabel = ancInt[!,[:nodenumber,:interval]], tipoffset=0.1);</code></pre><p>These plots tend to be quite busy, even for small networks.</p><p>As we know the true ancestral states here, we can compare them to our estimation. In this example, we see that the 95% prediction (ancestral state reconstruction) intervals contain the true simulated value, at all ancestral nodes.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pred = predict(ancTrait1, interval=:prediction);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; DataFrame(
         lower     = pred[1:7, :lower],                         # lower bound of 95% prediction interval
         trueValue = [3.312,4.438,3.922,3.342,2.564,1.315,2.0], # from sim1[:internalnodes] in next section
         upper     = pred[1:7, :upper]                          # upper bound
        )</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">7×3 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> lower     trueValue  upper   </span>
     │<span class="sgr90"> Float64   Float64    Float64 </span>
─────┼──────────────────────────────
   1 │ 2.58017       3.312  3.80452
   2 │ 3.68691       4.438  5.37222
   3 │ 2.03613       3.922  5.21973
   4 │ 1.50814       3.342  5.37317
   5 │ 0.612833      2.564  4.57165
   6 │ 0.918271      1.315  4.08182
   7 │ 2.0           2.0    2.0</code></pre><h3 id="From-estimated-parameters"><a class="docs-heading-anchor" href="#From-estimated-parameters">From estimated parameters</a><a id="From-estimated-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#From-estimated-parameters" title="Permalink"></a></h3><p>In real applications though, we do not have access to the true parameters of the process that generated the data. We can estimate them using the previous function. To fit a regular BM, we just need to do a regression of trait 1 against a simple intercept:</p><pre><code class="language-julia hljs">fitTrait1 = phylolm(@formula(trait1 ~ 1), dat, truenet)</code></pre><p>We can then apply the <a href="../../lib/public/#PhyloTraits.ancestralreconstruction"><code>ancestralreconstruction</code></a> function directly to the fitted object:</p><pre><code class="language-julia hljs">ancTrait1Approx = ancestralreconstruction(fitTrait1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">┌ Warning: </span></span>These prediction intervals show uncertainty in ancestral values,
<span class="sgr33"><span class="sgr1">│ </span></span>assuming that the estimated variance rate of evolution is correct.
<span class="sgr33"><span class="sgr1">│ </span></span>Additional uncertainty in the estimation of this variance rate is
<span class="sgr33"><span class="sgr1">│ </span></span>ignored, so prediction intervals should be larger.
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ PhyloTraits ~/work/PhyloTraits.jl/PhyloTraits.jl/src/ancestral_continuous.jl:312</span></code></pre><p>The prediction intervals ignore the fact that we estimated the process parameters, so they are less accurate and the function throws a warning. Note that this warning will only show once in a given <code>julia</code> session. The output is an object of the same <a href="../../lib/public/#PhyloTraits.ReconstructedStates"><code>ReconstructedStates</code></a> type as earlier, and the same extractors can be applied to it:</p><pre><code class="language-julia hljs">plot(truenet, nodelabel = predict(ancTrait1Approx, text = true));</code></pre><p><img src="../../assets/figures/ancestral1.svg" alt="ancestral1"/></p><p>For convenience, the two steps described above (fitting against the intercept, and then do ancestral state reconstruction) can be done all at once with a single call of the function <a href="../../lib/public/#PhyloTraits.ancestralreconstruction"><code>ancestralreconstruction</code></a> on a DataFrame with the trait to reconstruct, and the tip labels:</p><pre><code class="language-julia hljs">datTrait1 = DataFrame(trait1 = dat[:,:trait1], tipnames = dat[:,:tipnames])
ancTrait1Approx = ancestralreconstruction(datTrait1, truenet)</code></pre><pre><code class="language-julia hljs">ancInt = predict(ancTrait1Approx, interval=:prediction, level=0.9, text=true, combine=true)
plot(truenet, nodelabel = ancInt[!,[:nodenumber,:interval]]);</code></pre><p><img src="../../assets/figures/ancestral2.svg" alt="ancestral2"/></p><p>This produces the exact same results. Here, we chose a <code>level</code> of 90% for the plotted prediction intervals.</p><h3 id="Data-imputation"><a class="docs-heading-anchor" href="#Data-imputation">Data imputation</a><a id="Data-imputation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-imputation" title="Permalink"></a></h3><p>Note that there is no theoretical difference between an internal node, for which we could not measure the value of the trait, and a missing value at a tip of the network. Consequently, the previous <a href="../../lib/public/#PhyloTraits.ancestralreconstruction"><code>ancestralreconstruction</code></a> function can be used to do data imputation. To see this, let&#39;s add some missing values in trait 1.</p><pre><code class="language-julia hljs">allowmissing!(datTrait1, :trait1)
datTrait1[2, :trait1] = missing; # second row: for taxon C
ancTrait1Approx = ancestralreconstruction(datTrait1, truenet)</code></pre><pre><code class="language-julia hljs">ancInt = predict(ancTrait1Approx, interval=:prediction, text=true, combine=true)
plot(truenet, nodelabel = ancInt[!,[:nodenumber,:interval]]);</code></pre><p><img src="../../assets/figures/ancestral3.svg" alt="ancestral3"/></p><p>A prediction interval is shown for the missing values.</p><h3 id="With-known-predictors"><a class="docs-heading-anchor" href="#With-known-predictors">With known predictors</a><a id="With-known-predictors-1"></a><a class="docs-heading-anchor-permalink" href="#With-known-predictors" title="Permalink"></a></h3><p>At this point, it might be tempting to apply this function to trait 3 as a linear combination of trait 1 and a phylogenetic noise, to get a better ancestral state reconstruction via using its correlation with trait 1. However, this cannot be done directly:</p><pre><code class="language-julia hljs">ancTrait3 = ancestralreconstruction(fitTrait3) # throws an error</code></pre><p>This is because the model to fit the trait (a regression with one predictor and an intercept) used a predictor for which we don&#39;t know the ancestral states. The regression model accounted for that.</p><p>The only option we have is to provide the function with the predictor&#39;s ancestral states, if they are known. They are actually known in this toy example because we generated the data ourselves (see next section), so we can reconstruct our trait doing the following:</p><pre><code class="language-julia hljs">ancTrait3 = ancestralreconstruction(fitTrait3, # model with estimated coefs etc.
  hcat(ones(7,1),
  [ 3.312, 4.438,  3.922,  3.342,  2.564,  1.315,  2.0], # from sim1[:internalnodes]
  [-3.62, -0.746, -2.217, -3.612, -2.052, -2.871, -2.0]) # from sim2[:internalnodes]
)</code></pre><pre><code class="language-julia hljs">ancInt = predict(ancTrait3, interval=:prediction, text=true, combine=true)
plot(truenet, nodelabel = ancInt[!,[:nodenumber,:interval]]);</code></pre><p><img src="../../assets/figures/ancestral4.svg" alt="ancestral4"/></p><p>where we provided the ancestral predictors as a matrix, containing the intercept, and the known predictor at internal nodes. We must be very careful with this function, as no check is done for the order of the predictors, or the order of their values that must be the same as the internal nodes of the phylogeny. As ancestral predictors are often unknown, the use of this functionality is discouraged.</p><h2 id="Phylogenetic-ANOVA"><a class="docs-heading-anchor" href="#Phylogenetic-ANOVA">Phylogenetic ANOVA</a><a id="Phylogenetic-ANOVA-1"></a><a class="docs-heading-anchor-permalink" href="#Phylogenetic-ANOVA" title="Permalink"></a></h2><p>The <a href="../../lib/public/#PhyloTraits.phylolm"><code>phylolm</code></a> function is based on the <code>lm</code> function from <a href="https://github.com/JuliaStats/GLM.jl">GLM</a>. This means that it inherits from most of its features, and in particular, it can handle formulas with factors (discrete predictors) and interactions. For example, in lizards, we might want to do a regression of toe length on body length and the region where each species is found, where this region is coded into 4 categories (say). We might also want to include an interaction effect between body length and region. (This model is just meant to show the possibilities of the function).</p><p>To illustrate the use of categorical predictors of particular interest in a network with reticulations, let&#39;s assume that some transgressive evolution took place after the hybridization event, so that species &quot;A&quot; and &quot;B&quot; have a larger mean compared to the others (see <sup class="footnote-reference"><a id="citeref-B18" href="#footnote-B18">[B18]</a></sup> for transgressive evolution after a reticulation event).</p><pre><code class="language-julia hljs">δ = 5.0; # value of heterosis
underHyb = [n == &quot;A&quot; || n == &quot;B&quot; for n in dat[:,&quot;tipnames&quot;]] # tips under hybrid
underHyb
for i in 1:nrow(dat)
    underHyb[i] &amp;&amp; (dat[i,:trait3] += δ) # add delta to tips A and B
end</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; select(dat, [:trait3, :tipnames]) # trait3 changed: +5 added to A and B by previous loop</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">6×2 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> trait3   tipnames </span>
     │<span class="sgr90"> Float64  String   </span>
─────┼───────────────────
   1 │  15.424  D
   2 │  17.333  C
   3 │  23.115  A
   4 │  23.81   B
   5 │  13.337  E
   6 │  10.012  O</code></pre><p>The categorical variable <code>underHyb</code> separates tips &quot;A&quot; and &quot;B&quot; from the others. We need to consider it as a factor, not a numerical variable. One way is to make it a vector of strings, as done below. An alternative way would be to add and use the <code>CategoricalArrays</code> package, then transform the column <code>underHyb</code> to be <code>categorical</code> (shown in commments).</p><pre><code class="language-julia hljs">dat.underHyb = string.(underHyb); # adds a new column
# using CategoricalArrays
# transform!(dat, :underHyb =&gt; categorical, renamecols=false)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dat</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">6×5 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> trait1   trait2   trait3   tipnames  underHyb </span>
     │<span class="sgr90"> Float64  Float64  Float64  String    String   </span>
─────┼───────────────────────────────────────────────
   1 │   2.668   -3.008   15.424  D         false
   2 │   3.696   -4.146   17.333  C         false
   3 │   4.541   -2.338   23.115  A         true
   4 │   4.846    0.655   23.81   B         true
   5 │   2.268   -3.339   13.337  E         false
   6 │  -0.331   -4.566   10.012  O         false</code></pre><p>Now we can include this reticulation variable in the regression.</p><pre><code class="language-julia hljs">fitTrait = phylolm(@formula(trait3 ~ trait1 + underHyb), dat, truenet)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PhyloNetworkLinearModel

Formula: trait3 ~ 1 + trait1 + underHyb

Model: Brownian motion

Parameter Estimates, using REML:
phylogenetic variance rate: 0.0488024

Coefficients:
───────────────────────────────────────────────────────────────────────────
                   Coef.  Std. Error      t  Pr(&gt;|t|)  Lower 95%  Upper 95%
───────────────────────────────────────────────────────────────────────────
(Intercept)     10.1488     0.515463  19.69    0.0003    8.50838   11.7892
trait1           1.83155    0.158081  11.59    0.0014    1.32846    2.33463
underHyb: true   4.8284     0.642348   7.52    0.0049    2.78416    6.87264
───────────────────────────────────────────────────────────────────────────
Log Likelihood: -3.0738309703
AIC: 14.1476619407
</code></pre><p>In this case, the categorical variable indicating which tips are descendants of the reticulation event is indeed relevant, and the transgressive evolution effect is recovered.</p><p>This is a very simple example of how to include transgressive evolution, but some general functions to test for it, on networks with more than one hybrid, are also available.</p><h2 id="Pagel&#39;s-Lambda"><a class="docs-heading-anchor" href="#Pagel&#39;s-Lambda">Pagel&#39;s Lambda</a><a id="Pagel&#39;s-Lambda-1"></a><a class="docs-heading-anchor-permalink" href="#Pagel&#39;s-Lambda" title="Permalink"></a></h2><p>One classical question about trait evolution is the amount of &quot;phylogenetic signal&quot; in a trait or in the residuals of a linear relationship, that is, the importance of the tree structure to explain variation in the observed traits (or in the residuals). One way of measuring that is to use Pagel&#39;s lambda transformation of the branch lengths <sup class="footnote-reference"><a id="citeref-P99" href="#footnote-P99">[P99]</a></sup>. This model assumes a BM on a tree where the internal branches are multiplied by a factor λ, while the external branches are modified so that the total height of the tree is constant. Hence, λ varies between 0 (the tree has no influence on the data) and 1 (the tree is unchanged). Using the same branch length transformations, this model can be straightforwardly extended to phylogenetic networks.</p><p>This transformation assumes a time-consistent and ultrametric phylogeny, in which all paths from the root to any tip has the same length: the &quot;height&quot; of the phylogeny referred to above.</p><p>We can illustrate this with the predictor trait we used earlier. We use the same function as before, only indicating the model we want to use:</p><pre><code class="language-julia hljs">fitPagel = phylolm(@formula(trait1 ~ 1), dat, truenet, model=&quot;lambda&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PhyloNetworkLinearModel

Formula: trait1 ~ 1

Model: Pagel&#39;s lambda

Parameter Estimates, using REML:
phylogenetic variance rate: 0.447101
Lambda: 0.967759

Coefficients:
─────────────────────────────────────────────────────────────────────
              Coef.  Std. Error     t  Pr(&gt;|t|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────
(Intercept)  2.1801     1.29435  1.68    0.1529   -1.14715    5.50734
─────────────────────────────────────────────────────────────────────
Log Likelihood: -9.4622859932
AIC: 24.9245719865
</code></pre><p>As this trait 1 was indeed generated according to a plain BM on the phylogeny (see next section), the estimated λ should be close to 1. It can be extracted with function <code>lambda_estim</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; lambda_estim(fitPagel)</code><code class="nohighlight hljs ansi" style="display:block;">0.9677585415846363</code></pre><p>For models in which the covariance is estimated, like Pagel&#39;s lambda, model comparisons should use a likelihood ratio test with the function <code>lrtest</code>, because the f-test (see below) is not applicable.</p><p>If the models being compared have different predictors, then models should be fit with maximum likelihood instead of the default REML criterion in order to do a likelihood ratio test: use option <code>reml=false</code> for this.</p><h2 id="Test-of-transgressive-evolution"><a class="docs-heading-anchor" href="#Test-of-transgressive-evolution">Test of transgressive evolution</a><a id="Test-of-transgressive-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Test-of-transgressive-evolution" title="Permalink"></a></h2><p>In the ANOVA section above, we showed how to include transgressive evolution in a simple case, and we did so manually. In general, transgressive evolution can be seen as a particular example of a <em>shifted BM</em> on the phylogenetic network, in which the trait evolves as a BM on the network, but <em>shifts</em> at a reticulation. The value of the shift may be the same across all reticulations, or may differ between reticulations.</p><p>For identifiability reasons, each transgressive shift is applied to the edge below a reticulation. In our network above, there is a single reticulation and the edge below it is edge 6:</p><pre><code class="language-julia hljs">plot(truenet, useedgelength=true, showedgenumber=true);</code></pre><p><img src="../../assets/figures/truenet_with_numbers.svg" alt="truenet_with_numbers"/></p><p>Let&#39;s assume we measured a trait that we hypothesized underwent a shift at some or all ancestral reticulations. To test this hypothesis, we can use the  custom columns of the <a href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/public/#PhyloNetworks.descendencematrix-Tuple%7BHybridNetwork%7D"><code>PhyloNetworks.descendencematrix</code></a>, that can be directly defined thanks to function <a href="../../lib/public/#PhyloTraits.descendencedataframe-Tuple{PhyloNetworks.HybridNetwork, Vector{PhyloNetworks.Node}}"><code>descendencedataframe</code></a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_shift = descendencedataframe(truenet) # regressors matching Hybrid Shifts</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">6×3 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> shift_6  tipnames  sum     </span>
     │<span class="sgr90"> Float64  String    Float64 </span>
─────┼────────────────────────────
   1 │     0.0  D             0.0
   2 │     0.0  C             0.0
   3 │     1.0  A             1.0
   4 │     1.0  B             1.0
   5 │     0.0  E             0.0
   6 │     0.0  O             0.0</code></pre><p>This creates a dataframe, with one column for each hybrid node in the network, named according to the number of the edge after the hybrid. In column <code>shift_6</code>, a row has a 0 if the corresponding species is <em>not</em> a descendant of the reticulation, otherwise has the proportion of its genome that was inherited from this reticulation. Here, A and B&#39;s ancestry if fully inherited from edge 6, below the one reticulation in the network.</p><p>We can use the columns in this dataframe as regressors (predictors) in the <a href="../../lib/public/#PhyloTraits.phylolm"><code>phylolm</code></a> function. Their coefficients will measure the shift after each reticulation. In the example below, the species names are listed in a different order than in <code>df_shift</code>, and contained in a column called &quot;species&quot;, to show how this is handled to merge and then fit the data.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dat = DataFrame(  # trait data
         trait = [3.510, 2.195, 1.869, 4.839, 5.027, -0.679],
         species = [&quot;O&quot;, &quot;D&quot;, &quot;C&quot;, &quot;A&quot;, &quot;B&quot;, &quot;E&quot;]);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dat = innerjoin(dat, df_shift, on = [:species =&gt; :tipnames]) # trait + shift predictors</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">6×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> trait    species  shift_6  sum     </span>
     │<span class="sgr90"> Float64  String   Float64  Float64 </span>
─────┼────────────────────────────────────
   1 │   2.195  D            0.0      0.0
   2 │   1.869  C            0.0      0.0
   3 │   4.839  A            1.0      1.0
   4 │   5.027  B            1.0      1.0
   5 │  -0.679  E            0.0      0.0
   6 │   3.51   O            0.0      0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fit_sh = phylolm(@formula(trait ~ shift_6), dat, truenet, tipnames=:species) # fit</code><code class="nohighlight hljs ansi" style="display:block;">PhyloNetworkLinearModel

Formula: trait ~ 1 + shift_6

Model: Brownian motion

Parameter Estimates, using REML:
phylogenetic variance rate: 0.251587

Coefficients:
──────────────────────────────────────────────────────────────────────
               Coef.  Std. Error     t  Pr(&gt;|t|)  Lower 95%  Upper 95%
──────────────────────────────────────────────────────────────────────
(Intercept)  1.73145     1.01968  1.70    0.1647  -1.09963     4.56253
shift_6      3.74996     1.20279  3.12    0.0356   0.410472    7.08944
──────────────────────────────────────────────────────────────────────
Log Likelihood: -5.9281391748
AIC: 17.8562783496</code></pre><p>Here, because there is only one hybrid in the network, we can directly see whether the ancestral transgressive evolution is significant or not thanks to the Student T-test on the coefficient associated with <code>shift_6</code>. In more complex cases, it is possible to do a Fisher F-test, thanks to the <code>GLM</code> function <code>ftest</code>.</p><pre><code class="language-julia hljs">fit_null = phylolm(@formula(trait ~ 1), dat, truenet, tipnames=:species) # null (no shift)
ftest(fit_null, fit_sh)  # nested models</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">F-test: 2 models fitted on 6 observations
───────────────────────────────────────────────────────────────
     DOF  ΔDOF     SSR     ΔSSR      R²     ΔR²      F*   p(&gt;F)
───────────────────────────────────────────────────────────────
[1]    2        3.4518           0.0000                        
[2]    3     1  1.0063  -2.4455  0.7085  0.7085  9.7201  0.0356
───────────────────────────────────────────────────────────────</code></pre><p>Here, this test is equivalent to the Fisher F test, and gives the same p-value.</p><div class="admonition is-info"><header class="admonition-header">Warnings from GLM</header><div class="admonition-body"><p>A warning may appear, saying &quot;Starting from GLM.jl 1.8, null model is defined as having no predictor at all when a model without an intercept is passed.&quot;</p><ul><li>Why? <code>ftest</code> is inherited from the GLM package, which does not know that the intercept term is not a column of ones after transformation to remove the phylogenetic correlation. This is why <code>ftest</code> sends a warning for each model, when multiple models are compared.</li><li>These specific warnings can be ignored:<ul><li>F values and p-values are correct</li><li>R² values are also correct: they are obtained with the <code>r2</code> function for phylogenetic linear models.</li></ul></li></ul><p>A future version of the package will attempt to remove these warnings specifically.</p></div></div><p>Note that models need to be ordered by complexity, when given to <code>ftest</code>: either from most complex to most simple, or from most simple to most complex. In the output table, models are listed in the order in which they were given. If the most complex model is given first, as done above, the table lists the most complex H₁ (with shifts) first, and the null model H₀ is listed as the second model.</p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-B18"><a class="tag is-link" href="#citeref-B18">B18</a>Bastide, Solís-Lemus, Kriebel, Sparks, Ané (2018): Phylogenetic Comparative Methods for Phylogenetic Networks with Reticulations. Systematic Biology 67(5):800–820. doi:10.1093/sysbio/syy033</li><li class="footnote" id="footnote-P99"><a class="tag is-link" href="#citeref-P99">P99</a>Pagel M (1999). Inferring the historical patterns of biological evolution. Nature. 401: 877–884. doi:10.1038/44766</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../simulate_continuous/">Continuous trait simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Monday 17 March 2025 19:47">Monday 17 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
